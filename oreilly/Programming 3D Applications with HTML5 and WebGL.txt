<section class="chapter" data-original-filename="ch02.xml" id="webgl_colon_real-time_3d_rendering"><div class="titlepage"><div><div><h1 class="title">Chapter 2. WebGL: Real-time 3D Rendering</h1></div></div></div>
<p id="webgl_is_the_st">WebGL is the standard 3D graphics API for the web. It allows developers to harness the full power of the computer’s 3D rendering hardware from within the browser using JavaScript. Before WebGL, developers had to rely on plugins or native applications and ask their users to download and install custom software in order to deliver a hardware-accelerated 3D experience.</p>
<p id="while_webgl_is_">While WebGL is not in the official HTML5 specification, it is shipped with most browsers that support HTML5. Like Web Workers, Web Sockets and other technologies outside the official W3C recommendations, WebGL comes with the package; the developers at Google, Apple, Mozilla, Opera and Blackberry consider 3D an essential component for making the browser into a first-class application platform.</p>
<p id="webgl_works_on_">WebGL works on the majority of desktops, as well as a growing number of mobile browsers. There are millions of WebGL-enabled seats already installed, most likely including the machines you run at home and in your office. There are numerous sites under development, with applications including games, data visualization, computer-aided design, 3D printing, and consumer retail.</p>
<p id="webgl_is_a_low">WebGL is a low-level drawing API: you supply it with arrays of data and a shader, and tell it to draw. Anyone used to a graphics API like the 2D Canvas will find the lack of high-level constructs mystifying at first. However, there are several open source JavaScript toolkits that provider higher-level access to the API to make it look more like a traditional drawing library. Even with a toolkit, 3D is still hard work— but these tools at least make approachable for folks with limited 3D development experience; and for experienced 3D developers, they are definitely time-savers.</p>
<p id="in_this_chapter">In this chapter we will take a quick tour of the low-level underpinnings of WebGL, to give you a foundation. For the majority of the book we will be using toolkit software that hides most of the API details. But it is important to know what these tools are built upon, so let’s start by exploring WebGL’s core concepts and API.</p>
<div class="sect1" data-original-filename="ch02.xml" id="webgl_n_a_technical_definition">
<div class="titlepage"><div><div><h2 class="title">WebGL – A Technical Definition</h2></div></div></div>
<p id="webgl_is_develo">WebGL is developed and maintained by the Khronos group, the standards body that also governs OpenGL, COLLADA and other specifications you may have heard of. Here is the official description of WebGL, from the Khronos web site:</p>
<div class="blockquote"><blockquote class="blockquote"><p id="webgl_is_a_roya">WebGL is a royalty-free, cross-platform API that brings OpenGL ES 2.0 to the web as a 3D drawing context within HTML, exposed as low-level Document Object Model interfaces. It uses the OpenGL shading language, GLSL ES, and can be cleanly combined with other web content that is layered on top or underneath the 3D content. It is ideally suited for dynamic 3D web applications in the JavaScript programming language, and will be fully integrated in leading web browsers.</p></blockquote></div>
<p id="this_definition">This definition comprises several core ideas. Let’s deconstruct them here.</p>
<div class="itemizedlist" id="webgl_is_an_api_id1"><ul class="itemizedlist">
<li class="listitem"><p id="webgl_is_an_api_id2"><span class="strong"><strong>WebGL is an API</strong></span>. WebGL is accessed exclusively through a set of JavaScript programming interfaces; there are no accompanying tags like there are with HTML. 3D rendering in WebGL is analogous to 2D drawing using the Canvas element, in that it is all done through JavaScript API calls. In fact, access to WebGL is provided using the existing Canvas element and obtaining a special drawing context specific to WebGL.</p></li>
<li class="listitem"><p id="webgl_is_based__id1"><span class="strong"><strong>WebGL is based on OpenGL ES 2.0</strong></span>. OpenGL ES is an adaption of the long-established 3D rendering standard OpenGL. The “ES” stands for “embedded systems,” meaning that it has been tailored for use in small computing devices, most notably phones and tablets. OpenGL ES is the API that powers 3D graphics for iPhone, iPad, Android phones and Android tablets. WebGL’s designers felt that, by basing the API on OpenGL ES’s small footprint, it would be more achievable to deliver a consistent, cross-platform, cross-browser 3D API for the web.</p></li>
<li class="listitem"><p id="webgl_combines_"><span class="strong"><strong>WebGL combines with other web content</strong></span>. WebGL layers on top of or underneath other page content. The 3D canvas can take up just a portion of the page, or the whole page. It can reside inside <code class="literal">&lt;div&gt;</code> tags that are z-ordered. This means that you develop your 3D graphics using WebGL, but all your other elements are built using familiar old HTML. The browser composites (combines) all of the graphics on the page into a seamless experience for the user.</p></li>
<li class="listitem"><p id="webgl_is_built_"><span class="strong"><strong>WebGL is built for dynamic web applications</strong></span>. WebGL has been designed with web delivery in mind. WebGL starts with OpenGL ES, but it has been adapted with specific features that integrate well with web browsers, work with the JavaScript language, and are friendly for web delivery.</p></li>
<li class="listitem"><p id="webgl_is_cross"><span class="strong"><strong>WebGL is cross-platform</strong></span>. WebGL is capable of running on any operating system, on devices ranging from phones and tablets to desktop computers.</p></li>
<li class="listitem"><p id="webgl_is_royalt"><span class="strong"><strong>WebGL is royalty-free</strong></span>. Like all open web specifications, WebGL is free to use. Nobody will be asking you to pay royalties for the privilege.</p></li>
</ul></div>
<p id="the_makers_of_c">The makers of Chrome, Firefox, Safari, Opera and the Blackberry browser have committed significant resources to developing and supporting WebGL, and engineers from these teams are also key members of the working group that develops the specification. The WebGL specification process is open to all Khronos members, and there are also mailing lists open to the public. See appendix X for a list of mailing lists and other specification resources.</p>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="the_webgl_api">
<div class="titlepage"><div><div><h2 class="title">The WebGL API</h2></div></div></div>
<p id="webgl_is_based__id2">WebGL is based on the long-established graphics API known as OpenGL. Originally developed in the late 1980’s, OpenGL has been an industry standard API for a very long time, having endured competitive threats from Microsoft Direct X to emerge as the undisputed standard for programming 3D graphics.</p>
<p id="but_not_all_ope">But not all OpenGL’s are the same. The characteristics of various platforms, including desktop computers, set-top televisions, smart phones and tablets, are so divergent that different editions of OpenGL had to be developed. OpenGL ES (for “embedded systems”) is the version of OpenGL developed to run on small devices such as set-top TV’s and smart phones. Perhaps unforeseen at the time of its development, it turns out the OpenGL ES forms the ideal core for WebGL. It is small and lean, which means that not only is it (relatively) straightforward to implement in a browser, but it makes it much more likely that the developers of the different browsers implement it consistently, and that a WebGL application written for one browser will work identically in another browser.</p>
<p id="the_lean_nature">The lean nature of WebGL puts the onus on application developers to do a lot of work. There is no DOM representation of the 3D scene; there are no natively supported 3D file formats for loading geometry and animations; and with the exception of a few low-level system events, there is no built-in event model to report the goings-on within the 3D canvas—e.g. no mouse-click events telling you what object was clicked on. To the average web developer, WebGL represents a steep learning curve full of truly alien concepts.</p>
<p id="the_good_news_h">The good news here is that there are several open source code libraries out there that make WebGL development approachable. Think of them as existing at the level of JQuery or Prototype.js, though the analogy is rough at best. We will be talking about these libraries in the next few chapters. But right now, we are going to take a quick tour of the underpinnings, the drive train if you will, of WebGL. Even if you never write low-level WebGL for your projects, it’s good to know what’s happening under the hood.</p>
<p id="perhaps_a_quick">Perhaps a quick history of the API, starting with Vlad’s Canvas3D work.</p>
<div class="sect2" id="the_anatomy_of_a_webgl_application">
<div class="titlepage"><div><div><h3 class="title">The Anatomy of a WebGL Application</h3></div></div></div>
<p id="at_the_end_of_t">At the end of the day, WebGL is just a drawing library; another kind of canvas, akin to the 2D Canvas supported in all HTML5 browsers. In fact, WebGL actually uses the HTML5 <code class="literal">&lt;canvas&gt;</code> element to get 3D graphics into the browser page.</p>
<p id="in_order_to_ren_id2">In order to render WebGL into a page, an application must, at a minimum, perform the following steps:</p>
<div class="orderedlist" id="create_a_canvas_id1"><ol class="orderedlist" type="1">
<li class="listitem"><p id="create_a_canvas_id2">Create a canvas element</p></li>
<li class="listitem"><p id="obtain_a_drawin">Obtain a drawing context for the canvas</p></li>
<li class="listitem"><p id="initialize_the__id1">Initialize the viewport</p></li>
<li class="listitem"><p id="create_one_or_m_id1">Create one or more buffers containing the data to be rendered (typically vertices)</p></li>
<li class="listitem"><p id="create_one_or_m_id2">Create one or more matrices to define the transformation from vertex buffers to screen space</p></li>
<li class="listitem"><p id="create_one_or_m_id3">Create one or more shaders to implement the drawing algorithm</p></li>
<li class="listitem"><p id="initialize_the__id2">Initialize the shaders with parameters</p></li>
<li class="listitem"><p id="draw">Draw</p></li>
</ol></div>
<p id="lets_look_at_a">Let’s look at a few examples to illustrate this flow.</p>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="a_simple_webgl_example">
<div class="titlepage"><div><div><h2 class="title">A Simple WebGL Example</h2></div></div></div>
<p id="to_illustrate_t">To illustrate the basic workings of the WebGL API, we are going to write very simple code that draws a single white square on the canvas. See the file <code class="filename">Chapter 2/example2-1.html</code> for a full code listing. The result is shown in <a class="xref" href="ch02.html#a_square_drawn_with_webgl" title="Figure 2-1. A Square Drawn with WebGL">Figure 2-1</a>.</p>
<div class="figure" id="a_square_drawn_with_webgl">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_2-1.png" alt="A Square Drawn with WebGL"></div></div>
<div class="figure-title">Figure 2-1. A Square Drawn with WebGL</div>
</div>
<div class="note" id="the_samples_in__id1"><p id="the_samples_in__id2">The samples in this section are heavily inspired by the lessons at Learning WebGL (<a class="ulink" href="http://www.learningwebgl.com/" target="_top">http://www.learningwebgl.com/</a>), a wonderful site originally developed by Giles Thomas (<a class="ulink" href="http://www.gilesthomas.com/" target="_top">http://www.gilesthomas.com/</a>). Learning WebGL is a fantastic resource for getting to know the WebGL API through tutorials, as well as seeing what cool things are being developed with WebGL around the globe.</p></div>
<div class="sect2" id="the_canvas_element_and_webgl_drawing_con">
<div class="titlepage"><div><div><h3 class="title">The Canvas Element and WebGL Drawing Context</h3></div></div></div>
<p id="all_webgl_rende">All WebGL rendering takes place in a <span class="emphasis"><em>context</em></span>, a browser DOM object that provides the complete WebGL API. This structure mirrors the 2D drawing context provided in the HTML5 Canvas element. To get WebGL into your web page, create a <code class="literal">&lt;canvas&gt;</code> tag somewhere on the page, get the DOM object associated with it (say, using <code class="literal">document.getElementById()</code>), and then get a WebGL context for it. <a class="xref" href="ch02.html#obtaining_a_webgl_context_from_a_canvas" title="Example 2-1. Obtaining a WebGL Context from a Canvas">Example 2-1</a> shows how to get the WebGL context from a canvas DOM element.</p>
<div class="example" id="obtaining_a_webgl_context_from_a_canvas">
<div class="example-title">Example 2-1. Obtaining a WebGL Context from a Canvas</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_initwe">     <code class="kd">function</code> <code class="nx">initWebGL</code><code class="p">(</code><code class="nx">canvas</code><code class="p">)</code> <code class="p">{</code>

        <code class="kd">var</code> <code class="nx">gl</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">msg</code> <code class="o">=</code> <code class="s2">"Your browser does not support WebGL, "</code> <code class="o">+</code>
            <code class="s2">"or it is not enabled by default."</code><code class="p">;</code>
        <code class="k">try</code>
        <code class="p">{</code>
            <code class="nx">gl</code> <code class="o">=</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">getContext</code><code class="p">(</code><code class="s2">"experimental-webgl"</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="nx">msg</code> <code class="o">=</code> <code class="s2">"Error creating WebGL Context!: "</code> <code class="o">+</code> <code class="nx">e</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>
        <code class="p">}</code>

        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">gl</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="nx">alert</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">return</code> <code class="nx">gl</code><code class="p">;</code>
     <code class="p">}</code></pre></div>
</div>
<div class="note" id="note_the_tryca_id1"><p id="note_the_tryca_id2">Note the try/catch block in the example. This is very important, because some browsers still do not support WebGL, or even if they do, the user may not have the most recent version of that browser that includes WebGL support. Further, even browsers that do support WebGL may be running on old hardware, and not be able to give you a valid WebGL rendering context. So, detection code like the above will help you with deploying a fallback such as a rendering based on a 2D canvas— or at the very least, provide you with a graceful exit.</p></div>
</div>
<div class="sect2" id="the_viewport">
<div class="titlepage"><div><div><h3 class="title">The Viewport</h3></div></div></div>
<p id="once_you_have_o">Once you have obtained a valid WebGL drawing context from your canvas, you need to tell it the rectangular bounds of where to draw. In WebGL this is called a <span class="emphasis"><em>viewport</em></span>. Setting the viewport in WebGL is simple; just call the context’s <code class="literal">viewport()</code> method:</p>
<div class="example" id="setting_the_webgl_viewport">
<div class="example-title">Example 2-2. Setting the WebGL Viewport</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_initvi">    <code class="kd">function</code> <code class="nx">initViewport</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">canvas</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">viewport</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">width</code><code class="p">,</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">height</code><code class="p">);</code>
    <code class="p">}</code></pre></div>
</div>
<p id="recall_that_the">Recall that the <code class="literal">gl</code> object used here was created by our helper function <code class="literal">initWebGL()</code>. In this case we have initialized the WebGL viewport to take up the entire contents of the canvas’s display area.</p>
</div>
<div class="sect2" id="buffers_comma_arraybuffer_and_typed_arra">
<div class="titlepage"><div><div><h3 class="title">Buffers, ArrayBuffer and Typed Arrays</h3></div></div></div>
<p id="now_we_have_a_">Now, we have a context ready for drawing. This is pretty much where the similarities to 2D Canvas end.</p>
<p id="webgl_drawing_i">WebGL drawing is done with <span class="emphasis"><em>primitives</em></span>—types of objects to draw such as triangle sets (arrays of triangles), triangle strips (described below), points and lines. Primitives use arrays of data, called buffers, which define the positions of the vertices to be drawn. <a class="xref" href="ch02.html#creating_vertex_buffer_data" title="Example 2-3. Creating Vertex Buffer Data">Example 2-3</a> shows how to create the vertex buffer data for a unit (1×1) square. The results are returned in a JavaScript object containing the vertex buffer data, the size of a vertex structure (in this case, 3 floating point numbers to store x, y and z), the number of vertices to be drawn, and the type of primitive that will be used to draw the square, in this example, a triangle strip. A triangle strip is a rendering primitive that defines a sequence of triangles using the first three vertices for the first triangle, and each subsequent vertex in combination with the previous two for subsequent triangles.</p>
<div class="example" id="creating_vertex_buffer_data">
<div class="example-title">Example 2-3. Creating Vertex Buffer Data</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="create_the_v_id1">    <code class="c1">// Create the vertex data for a square to be drawn</code>
    <code class="kd">function</code> <code class="nx">createSquare</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">vertexBuffer</code><code class="p">;</code>
        <code class="nx">vertexBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">vertexBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">verts</code> <code class="o">=</code> <code class="p">[</code>
             <code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code><code class="p">,</code>
            <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code><code class="p">,</code>
             <code class="p">.</code><code class="mi">5</code><code class="p">,</code> <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code><code class="p">,</code>
            <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code> <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code>
        <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">verts</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">square</code> <code class="o">=</code> <code class="p">{</code><code class="nx">buffer</code><code class="o">:</code><code class="nx">vertexBuffer</code><code class="p">,</code> <code class="nx">vertSize</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code> <code class="nx">nVerts</code><code class="o">:</code><code class="mi">4</code><code class="p">,</code> <code class="nx">primtype</code><code class="o">:</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TRIANGLE_STRIP</code><code class="p">};</code>
        <code class="k">return</code> <code class="nx">square</code><code class="p">;</code>
    <code class="p">}</code></pre></div>
</div>
<p id="note_the_use_of">Note the use of the type <code class="literal">Float32Array</code>. This is a new data type introduced into web browsers for use with WebGL. <code class="literal">Float32Array</code> is a type of <span class="emphasis"><em>ArrayBuffer</em></span>, also known as a <span class="emphasis"><em>Typed Array</em></span>. This is a JavaScript type that stores compact binary data. Typed arrays can be accessed from JavaScript using the same syntax as ordinary arrays, but are much faster and consume less memory. They are ideal for use with binary data where performance is critical. Typed arrays can be put to general use, but their introduction into web browsers was pioneered by the WebGL effort. The latest typed array specification can be found on the Khronos web site at <a class="ulink" href="http://www.khronos.org/registry/typedarray/specs/latest/" target="_top">http://www.khronos.org/registry/typedarray/specs/latest/</a>.</p>
</div>
<div class="sect2" id="matrices">
<div class="titlepage"><div><div><h3 class="title">Matrices</h3></div></div></div>
<p id="before_we_can_d">Before we can draw the square, we must create a couple of matrices. First, we need a matrix to define where the square is positioned in our 3D coordinate system, relative to the camera. This is known as a <span class="emphasis"><em>ModelView matrix</em></span>, because it combines transformations of the model (3D mesh) and the camera. In our example, we are transforming the square by translating it along the negative z-axis, i.e. moving it away from the camera by −3.333 units. The second matrix we need is the <span class="emphasis"><em>projection matrix</em></span>, which will be required by our shader to convert the 3D space coordinates of the model in camera space into 2D coordinates drawn in the space of the viewport. In this example, the projection matrix defines a 45-degree field of view perspective camera.</p>
<p id="in_webgl_matri">In WebGL, matrices are represented simply as typed arrays of numbers; for example, a 4×4 matrix has a <code class="literal">Float32Array</code> of 16 elements. To help us with setting up and manipulating our matrices, we are using a great open source library called <span class="emphasis"><em>glMatrix</em></span> (<a class="ulink" href="https://github.com/toji/gl-matrix" target="_top">https://github.com/toji/gl-matrix</a>), written Brandon Jones, now an engineer at Google. The matrix setup code is shown in <a class="xref" href="ch02.html#setting_up_the_projection_and_modelview" title="Example 2-4. Setting Up the Projection and ModelView Matrices">Example 2-4</a>.</p>
<div class="example" id="setting_up_the_projection_and_modelview">
<div class="example-title">Example 2-4. Setting Up the Projection and ModelView Matrices</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_projectionm">    <code class="kd">var</code> <code class="nx">projectionMatrix</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">initMatrices</code><code class="p">(</code><code class="nx">canvas</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="c1">// Create a model view matrix with camera at 0, 0, −3.333</code>
        <code class="nx">modelViewMatrix</code> <code class="o">=</code> <code class="nx">mat4</code><code class="p">.</code><code class="nx">create</code><code class="p">();</code>
        <code class="nx">mat4</code><code class="p">.</code><code class="nx">translate</code><code class="p">(</code><code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="err">−</code><code class="mf">3.333</code><code class="p">]);</code>

        <code class="c1">// Create a project matrix with 45 degree field of view</code>
        <code class="nx">projectionMatrix</code> <code class="o">=</code> <code class="nx">mat4</code><code class="p">.</code><code class="nx">create</code><code class="p">();</code>
        <code class="nx">mat4</code><code class="p">.</code><code class="nx">perspective</code><code class="p">(</code><code class="nx">projectionMatrix</code><code class="p">,</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">/</code> <code class="mi">4</code><code class="p">,</code>
            <code class="nx">canvas</code><code class="p">.</code><code class="nx">width</code> <code class="o">/</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">height</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">10000</code><code class="p">);</code>
    <code class="p">}</code></pre></div>
</div>
</div>
<div class="sect2" id="the_shader">
<div class="titlepage"><div><div><h3 class="title">The Shader</h3></div></div></div>
<p id="we_are_almost_r">We are almost ready to draw our scene. There is one more important piece of setup: the shader. As described earlier, shaders are small programs written in GLSL, a high-level C-like language, which define how the pixels for 3D objects actually get drawn on the screen. WebGL requires the developer to supply a shader for each object that gets drawn. The shader can be used for multiple objects, so in practice it is often sufficient to supply one shader for the whole application, reusing it with different geometry and parameter values each time.</p>
<p id="a_shader_is_typ">A shader is typically composed of two parts: the <span class="emphasis"><em>vertex shader</em></span> and the <span class="emphasis"><em>fragment shader</em></span> (also known as the <span class="emphasis"><em>pixel shader</em></span>). The vertex shader is responsible for transforming the coordinates of the object into 2D display space; the fragment shader is responsible for generating the final color output of each pixel for the transformed vertices, based on inputs such as color, texture, lighting and material values. In our simple example, the vertex shader combines the <code class="literal">vertexPos</code>, <code class="literal">modelViewMatrix</code> and <code class="literal">projectionMatrix</code> values to create the final, transformed vertex for each input, and the fragment shader simply outputs a hard-coded white color.</p>
<p id="in_webgl_shade">In WebGL, shader setup requires a sequence of steps, including compiling the individual pieces from GLSL source code, then linking them together. <a class="xref" href="ch02.html#the_shader_code" title="Example 2-5. The Shader Code">Example 2-5</a> lists the shader code. Let’s walk through it. First, we define a helper function, <code class="literal">createShader()</code> that uses WebGL methods to compile the vertex and fragment shaders from source code. The GLSL source code is supplied as JavaScript strings that we define as global variables <code class="literal">vertexShaderSource</code> and <code class="literal">fragmentShaderSource</code>.</p>
<div class="note" id="in_the_examples_id1"><p id="in_the_examples_id2">In the examples in this chapter, GLSL source code is supplied as JavaScript strings stored in variables. This is a bit ugly, as we have to concatenate strings separated by newlines to construct our source. As an alternative, we could have defined the shader in external text files and loaded them via Ajax; or we could have created hidden DOM elements and tucked the source into their <code class="literal">textContent</code>. We did it this way for this example so that we could keep things simple for now.</p></div>
<p id="once_the_parts_">Once the parts of the shader have been compiled, they need to be linked together into a working program using the WebGL methods <code class="literal">gl.createProgram()</code>, <code class="literal">gl.attachShader()</code> and <code class="literal">gl.linkProgram()</code>. Once linking is successful, we have to do one more thing before we are ready to use the shader program: obtain a handle to each of the variables defined in the GLSL shader code so that they can be initialized with values from the JavaScript code. This is done using the WebGL methods <code class="literal">gl.getAttribLocation()</code> and <code class="literal">gl.getUniformLocation()</code>.</p>
<div class="example" id="the_shader_code">
<div class="example-title">Example 2-5. The Shader Code</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_create">        <code class="kd">function</code> <code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">str</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">shader</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">type</code> <code class="o">==</code> <code class="s2">"fragment"</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">shader</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">FRAGMENT_SHADER</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">type</code> <code class="o">==</code> <code class="s2">"vertex"</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">shader</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">VERTEX_SHADER</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="nx">gl</code><code class="p">.</code><code class="nx">shaderSource</code><code class="p">(</code><code class="nx">shader</code><code class="p">,</code> <code class="nx">str</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">compileShader</code><code class="p">(</code><code class="nx">shader</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">gl</code><code class="p">.</code><code class="nx">getShaderParameter</code><code class="p">(</code><code class="nx">shader</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">COMPILE_STATUS</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">alert</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">getShaderInfoLog</code><code class="p">(</code><code class="nx">shader</code><code class="p">));</code>
            <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="k">return</code> <code class="nx">shader</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">var</code> <code class="nx">vertexShaderSource</code> <code class="o">=</code>

        <code class="s2">"    attribute vec3 vertexPos;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 modelViewMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 projectionMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"        // Return the transformed and projected vertex value\n"</code> <code class="o">+</code>
        <code class="s2">"        gl_Position = projectionMatrix * modelViewMatrix * \n"</code> <code class="o">+</code>
        <code class="s2">"            vec4(vertexPos, 1.0);\n"</code> <code class="o">+</code>
        <code class="s2">"    }\n"</code><code class="p">;</code>

    <code class="kd">var</code> <code class="nx">fragmentShaderSource</code> <code class="o">=</code>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"    // Return the pixel color: always output white\n"</code> <code class="o">+</code>
        <code class="s2">"    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n"</code> <code class="o">+</code>
        <code class="s2">"}\n"</code><code class="p">;</code>


    <code class="kd">var</code> <code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">shaderVertexPositionAttribute</code><code class="p">,</code> <code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="nx">shaderModelViewMatrixUniform</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">initShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// load and compile the fragment and vertex shader</code>
        <code class="c1">//var fragmentShader = getShader(gl, "fragmentShader");</code>
        <code class="c1">//var vertexShader = getShader(gl, "vertexShader");</code>
        <code class="kd">var</code> <code class="nx">fragmentShader</code> <code class="o">=</code> <code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">fragmentShaderSource</code><code class="p">,</code> <code class="s2">"fragment"</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">vertexShader</code> <code class="o">=</code> <code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">vertexShaderSource</code><code class="p">,</code> <code class="s2">"vertex"</code><code class="p">);</code>

        <code class="c1">// link them together into a new program</code>
        <code class="nx">shaderProgram</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createProgram</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">attachShader</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">vertexShader</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">attachShader</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">fragmentShader</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">linkProgram</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">);</code>

        <code class="c1">// get pointers to the shader params</code>
        <code class="nx">shaderVertexPositionAttribute</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">getAttribLocation</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="s2">"vertexPos"</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">enableVertexAttribArray</code><code class="p">(</code><code class="nx">shaderVertexPositionAttribute</code><code class="p">);</code>

        <code class="nx">shaderProjectionMatrixUniform</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">getUniformLocation</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="s2">"projectionMatrix"</code><code class="p">);</code>
        <code class="nx">shaderModelViewMatrixUniform</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">getUniformLocation</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="s2">"modelViewMatrix"</code><code class="p">);</code>


        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">gl</code><code class="p">.</code><code class="nx">getProgramParameter</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">LINK_STATUS</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">alert</code><code class="p">(</code><code class="s2">"Could not initialise shaders"</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code></pre></div>
</div>
</div>
<div class="sect2" id="drawing_primitives">
<div class="titlepage"><div><div><h3 class="title">Drawing Primitives</h3></div></div></div>
<p id="now_we_are_rea">Now, we are ready to draw our square. Our context has been created; our viewport has been set; our vertex buffer, matrices and shader have been created and initialized. We define a function, <code class="literal">draw()</code>, which takes the WebGL context and our previously created square object. First, the function clears the canvas with a black background color. Then, it sets (“binds”) the vertex buffer for the square to be drawn, sets (“uses”) the shader to use, and connects up the vertex buffer and matrices to the shader as inputs. Finally, we call the WebGL <code class="literal">drawArrays()</code> method to draw the square. We simply tell it which type of primitive and how many vertices in the primitive; WebGL knows everything else already because we have previously set those other items (vertices, matrices, shaders) as state in the context.</p>
<div class="example" id="the_drawing_code">
<div class="example-title">Example 2-6. The Drawing Code</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_drawg_id1">     <code class="kd">function</code> <code class="nx">draw</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>

         <code class="c1">// clear the background (with black)</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">clearColor</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">);</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">clear</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">COLOR_BUFFER_BIT</code><code class="p">);</code>

         <code class="c1">// set the vertex buffer to be drawn</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">buffer</code><code class="p">);</code>

         <code class="c1">// set the shader to use</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">useProgram</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">);</code>

         <code class="c1">// connect up the shader parameters: vertex position and projection/model matrices</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderVertexPositionAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">vertSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">projectionMatrix</code><code class="p">);</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderModelViewMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">);</code>

         <code class="c1">// draw the object</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">drawArrays</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">primtype</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">nVerts</code><code class="p">);</code>
      <code class="p">}</code></pre></div>
</div>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="creating_3d_geometry">
<div class="titlepage"><div><div><h2 class="title">Creating 3D Geometry</h2></div></div></div>
<p id="the_square_was_">The square was about as simple a WebGL example as we can contrive. Obviously, it’s not very interesting—it’s not even 3D—yet it clocks in at nearly 200 lines of code. The corresponding 2D Canvas drawing code would be around 30 lines at most. At this point it’s clearly not a win over using other drawing APIs. But here is where it gets interesting. Now we are going to use WebGL to do true 3D drawing. We’ll need a few extra lines of code to create the geometry for a 3D cube with multiple colors, and we will have to make a few small changes to the shader and the drawing function. We are also going to throw in a simple animation so that we can see the cube from all sides. <a class="xref" href="ch02.html#a_multi-colored_cube" title="Figure 2-2. A Multi-Colored Cube">Figure 2-2</a> shows a screen shot of the cube in mid-rotation.</p>
<div class="figure" id="a_multi-colored_cube">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_2-2.png" alt="A Multi-Colored Cube"></div></div>
<div class="figure-title">Figure 2-2. A Multi-Colored Cube</div>
</div>
<p id="to_create_and_r">To create and render the cube, we need to adapt the previous example in a few places. First, we must change the code that creates the buffers to create cube geometry instead of square geometry. We also need to change the drawing code to use a different WebGL drawing method. File <code class="filename">Chapter 2/example2-2.html</code> contains the code.</p>
<p id="shows_the_buffe"><a class="xref" href="ch02.html#code_to_set_up_cube_geometry_comma_color" title="Example 2-7. Code to Set Up Cube Geometry, Color and Index Buffers">Example 2-7</a> shows the buffer setup for our cube. It is a bit more involved than the code to draw a square, not only because there are more vertices, but because we also want to supply different colors for each face of the cube. We first create the vertex buffer data and store it our variable <code class="literal">vertexBuffer</code>. Then, we create color data, one four-element color per vertex, and store it in <code class="literal">colorBuffer</code>. Finally, we create a new kind of buffer, called an <span class="emphasis"><em>index buffer</em></span>, to hold a set of indices into the vertex buffer data. We store this in the variable <code class="literal">cubeIndexBuffer</code>. This is done because the drawing primitive we will use in our updated <code class="literal">draw()</code> function requires indices into the set of vertices, instead of the vertices themselves, in order to define the triangles. Why do this? Because 3D geometry often represents contiguous, closed regions where vertex positions are shared among multiple triangles; indexed buffers allow the data to be stored more compactly by avoiding repetition of data.</p>
<div class="example" id="code_to_set_up_cube_geometry_comma_color">
<div class="example-title">Example 2-7. Code to Set Up Cube Geometry, Color and Index Buffers</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="create_the_v_id2">    <code class="c1">// Create the vertex, color and index data for a multi-colored cube</code>
    <code class="kd">function</code> <code class="nx">createCube</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// Vertex Data</code>
        <code class="kd">var</code> <code class="nx">vertexBuffer</code><code class="p">;</code>
        <code class="nx">vertexBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">vertexBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">verts</code> <code class="o">=</code> <code class="p">[</code>
           <code class="c1">// Front face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Back face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Top face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Bottom face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Right face</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Left face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code>
           <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">verts</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>

        <code class="c1">// Color data</code>
        <code class="kd">var</code> <code class="nx">colorBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">colorBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">faceColors</code> <code class="o">=</code> <code class="p">[</code>
            <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Front face</code>
            <code class="p">[</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Back face</code>
            <code class="p">[</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Top face</code>
            <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Bottom face</code>
            <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Right face</code>
            <code class="p">[</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">]</code>  <code class="c1">// Left face</code>
        <code class="p">];</code>
        <code class="kd">var</code> <code class="nx">vertexColors</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="k">in</code> <code class="nx">faceColors</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">color</code> <code class="o">=</code> <code class="nx">faceColors</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
            <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">j</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="mi">4</code><code class="p">;</code> <code class="nx">j</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">vertexColors</code> <code class="o">=</code> <code class="nx">vertexColors</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">color</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">vertexColors</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>

        <code class="c1">// Index data (defines the triangles to be drawn)</code>
        <code class="kd">var</code> <code class="nx">cubeIndexBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">cubeIndexBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">cubeIndices</code> <code class="o">=</code> <code class="p">[</code>
            <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code>      <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code>    <code class="c1">// Front face</code>
            <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code>      <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code>    <code class="c1">// Back face</code>
            <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code>     <code class="mi">8</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code>  <code class="c1">// Top face</code>
            <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code>   <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="c1">// Bottom face</code>
            <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code>   <code class="mi">16</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code> <code class="c1">// Right face</code>
            <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code>   <code class="mi">20</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code>  <code class="c1">// Left face</code>
        <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Uint16Array</code><code class="p">(</code><code class="nx">cubeIndices</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>

        <code class="kd">var</code> <code class="nx">cube</code> <code class="o">=</code> <code class="p">{</code><code class="nx">buffer</code><code class="o">:</code><code class="nx">vertexBuffer</code><code class="p">,</code> <code class="nx">colorBuffer</code><code class="o">:</code><code class="nx">colorBuffer</code><code class="p">,</code> <code class="nx">indices</code><code class="o">:</code><code class="nx">cubeIndexBuffer</code><code class="p">,</code>
                <code class="nx">vertSize</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code> <code class="nx">nVerts</code><code class="o">:</code><code class="mi">24</code><code class="p">,</code> <code class="nx">colorSize</code><code class="o">:</code><code class="mi">4</code><code class="p">,</code> <code class="nx">nColors</code><code class="o">:</code> <code class="mi">24</code><code class="p">,</code> <code class="nx">nIndices</code><code class="o">:</code><code class="mi">36</code><code class="p">,</code>
                <code class="nx">primtype</code><code class="o">:</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TRIANGLES</code><code class="p">};</code>

        <code class="k">return</code> <code class="nx">cube</code><code class="p">;</code>
    <code class="p">}</code></pre></div>
</div>
<p id="in_order_for_th">In order for the cube colors to be drawn, they must be passed to the shader. <a class="xref" href="ch02.html#shader_code_to_render_the_cube_with_colo" title="Example 2-8. Shader Code to Render the Cube with Colors">Example 2-8</a> shows the updated shader code. Note the lines in boldface: we declare a new vertex attribute to represent the color. We also need to declare a GLSL <code class="literal">varying</code> variable, <code class="literal">vColor</code>, which is used to pass per-vertex color information from the vertex shader to the fragment shader. Unlike <code class="literal">uniform</code> types such as the matrices discussed earlier, which do not change values from vertex to vertex, <code class="literal">varying</code> types represent information for which the shader can output a different value for each vertex. In this case, we are going to pull the color input from the color buffer data stored in memory in the <code class="literal">vertexColor</code> attribute. The fragment shader uses <code class="literal">vColor</code> unchanged to output the final pixel color value.</p>
<div class="example" id="shader_code_to_render_the_cube_with_colo">
<div class="example-title">Example 2-8. Shader Code to Render the Cube with Colors</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_vertexshade_id1">     <code class="kd">var</code> <code class="nx">vertexShaderSource</code> <code class="o">=</code>

        <code class="s2">"    attribute vec3 vertexPos;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    attribute vec4 vertexColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    uniform mat4 modelViewMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 projectionMatrix;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    varying vec4 vColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"        // Return the transformed and projected vertex value\n"</code> <code class="o">+</code>
        <code class="s2">"        gl_Position = projectionMatrix * modelViewMatrix * \n"</code> <code class="o">+</code>
        <code class="s2">"            vec4(vertexPos, 1.0);\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"        // Output the vertexColor in vColor\n"</code> <code class="o">+</code></strong></span>
        <span class="strong"><strong><code class="s2">"        vColor = vertexColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    }\n"</code><code class="p">;</code>

    <code class="kd">var</code> <code class="nx">fragmentShaderSource</code> <code class="o">=</code>
        <span class="strong"><strong><code class="s2">"    precision mediump float;\n"</code> <code class="o">+</code></strong></span>
        <span class="strong"><strong><code class="s2">"    varying vec4 vColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"    // Return the pixel color: always output white\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    gl_FragColor = vColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"}\n"</code><code class="p">;</code></pre></div>
</div>
<div class="note" id="this_code_may_s_id1"><p id="this_code_may_s_id2">This code may seem a bit complicated just to set a single color value. But a less trivial shader—such as one that implements a lighting model, or a shader that animates a procedural texture for grass, water or other effects—would perform many additional calculations on <code class="literal">vColor</code> before outputting the final color. No doubt that shaders provide a lot of visual power; but with that great power comes, as Ben Parker famously observed, great responsibility.</p></div>
<p id="now_for_the_dra">Now for the drawing code, shown in <a class="xref" href="ch02.html#revised_cube-drawing_code" title="Example 2-9. Revised Cube-Drawing Code">Example 2-9</a>. We have to do a few things differently for the more complex cube geometry. The lines in boldface show the changes. First, we make sure WebGL knows we are drawing depth-sorted 3D objects, by enabling depth testing. Next, we have to bind the color and index buffers created previously in the <code class="literal">createCube()</code> function. Finally, we use the WebGL method <code class="literal">gl.drawElements()</code> instead of <code class="literal">gl.drawArray()</code>. <code class="literal">gl.drawElements()</code> draws a set of primitives using indexed buffer information.</p>
<div class="example" id="revised_cube-drawing_code">
<div class="example-title">Example 2-9. Revised Cube-Drawing Code</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_drawg_id2">    <code class="kd">function</code> <code class="nx">draw</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// clear the background (with black)</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">clearColor</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">);</code>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">enable</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">DEPTH_TEST</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">clear</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">COLOR_BUFFER_BIT</code>  <code class="o">|</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">DEPTH_BUFFER_BIT</code><code class="p">);</code></strong></span>

        <code class="c1">// set the shader to use</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">useProgram</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">);</code>

         <code class="c1">// connect up the shader parameters: vertex position, color and projection/model matrices</code>
           <code class="c1">// set up the buffers</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">buffer</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderVertexPositionAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">vertSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">colorBuffer</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderVertexColorAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">colorSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">indices</code><code class="p">);</code></strong></span>

        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">projectionMatrix</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderModelViewMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">);</code>

        <span class="strong"><strong><code class="c1">// draw the object</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">drawElements</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">primtype</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">nIndices</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">UNSIGNED_SHORT</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span>
    <code class="p">}</code></pre></div>
</div>
<div class="sect2" id="adding_animation">
<div class="titlepage"><div><div><h3 class="title">Adding Animation</h3></div></div></div>
<p id="if_we_want_to_s">If we want to see the cube as a 3D object instead of a static 2D drawing, we need to animate it. For now we will use a very simple animation technique to tumble the cube around one axis. The animation code is shown in <a class="xref" href="ch02.html#animating_the_cube" title="Example 2-10. Animating the Cube">Example 2-10</a>. Function <code class="literal">animate()</code> rotates the cube around the previously defined <code class="literal">rotationAxis</code> over a period of 5 seconds.</p>
<p id="animate_is_ca"><code class="literal">animate()</code> is called repeatedly by another function, <code class="literal">run()</code>, which drives continuous animation of the 3D scene using a new browser function called <code class="literal">requestAnimationFrame()</code>. This function asks the browser to call a callback function when it is time to redraw the contents of the page. (We will explore <code class="literal">requestAnimationFrame()</code> and various animation techniques in detail in later chapters.) Each time <code class="literal">animate()</code> is called, it stores the difference between the current time and the previous time it was called into variable <code class="literal">deltat</code>, and uses that to derive an angle for rotating <code class="literal">modelViewMatrix</code>. The result is a full rotation around <code class="literal">rotationAxis</code> every 5 seconds.</p>
<div class="example" id="animating_the_cube">
<div class="example-title">Example 2-10. Animating the Cube</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_duration__">    <code class="kd">var</code> <code class="nx">duration</code> <code class="o">=</code> <code class="mi">5000</code><code class="p">;</code> <code class="c1">// ms</code>
    <code class="kd">var</code> <code class="nx">currentTime</code> <code class="o">=</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>
    <code class="kd">function</code> <code class="nx">animate</code><code class="p">()</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">now</code> <code class="o">=</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>
        <code class="kd">var</code> <code class="nx">deltat</code> <code class="o">=</code> <code class="nx">now</code> <code class="o">-</code> <code class="nx">currentTime</code><code class="p">;</code>
        <code class="nx">currentTime</code> <code class="o">=</code> <code class="nx">now</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">fract</code> <code class="o">=</code> <code class="nx">deltat</code> <code class="o">/</code> <code class="nx">duration</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">angle</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">fract</code><code class="p">;</code>
        <code class="nx">mat4</code><code class="p">.</code><code class="nx">rotate</code><code class="p">(</code><code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="nx">angle</code><code class="p">,</code> <code class="nx">rotationAxis</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="kd">function</code> <code class="nx">run</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">cube</code><code class="p">)</code> <code class="p">{</code>

        <code class="nx">requestAnimationFrame</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="nx">run</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">cube</code><code class="p">);</code> <code class="p">});</code>
        <code class="nx">draw</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">cube</code><code class="p">);</code>
        <code class="nx">animate</code><code class="p">();</code>
    <code class="p">}</code></pre></div>
</div>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="using_texture_maps">
<div class="titlepage"><div><div><h2 class="title">Using Texture Maps</h2></div></div></div>
<p id="the_final_webgl">The final WebGL API feature to explore in this chapter is texture mapping. <span class="emphasis"><em>Texture maps</em></span>, or simply <span class="emphasis"><em>textures</em></span>, are bitmap images displayed across the surface of geometry. Image data for textures is created using the <code class="literal">Image</code> DOM element, which means that standard web image formats such JPEG and PNG can be supplied to WebGL as textures by simply setting the <code class="literal">Image</code> element’s <code class="literal">src</code> property.</p>
<div class="note" id="webgl_textures__id1"><p id="webgl_textures__id2">WebGL textures don’t need to be created from image files. They can also be created using 2D <code class="literal">Canvas</code> elements, allowing us to draw on the surface of an object using the 2D Canvas drawing API; they can even be created from <code class="literal">Video</code> elements, enabling video playback on the surface of an object. These dynamic texturing capabilities will be explored in a later chapter.</p></div>
<p id="we_have_adapted">We have adapted the previous rotating cube example to use a texture map instead of face colors. The texture-mapped cube is depicted in <a class="xref" href="ch02.html#a_texture-mapped_cube" title="Figure 2-3. A Texture-Mapped Cube">Figure 2-3</a>.</p>
<div class="figure" id="a_texture-mapped_cube">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_2-3.png" alt="A Texture-Mapped Cube"></div></div>
<div class="figure-title">Figure 2-3. A Texture-Mapped Cube</div>
</div>
<div class="note" id="one_thing_about_id1">
<p id="one_thing_about_id2">One thing about this sample – in case you have been running it by opening the HTML file from your operating system’s file explorer. This one needs to be loaded from a web server, because we are loading a texture map from a JPEG file, which, because of cross-origin security restrictions in WebGL’s security model, requires web server operation rather than access via <code class="literal">file://</code> URLs. In general, most of the examples in this book must be loaded from a web server.</p>
<p id="i_run_a_local_v">I run a local version of a standard LAMP stack on my MacBook... but all you really need is the ‘A’ part of LAMP, i.e. a web server such as Apache. Or if you have Python installed, another option is the SimpleHTTPServer module, which you can run by going to the root of the examples directory and typing</p>
<p id="python_m_simpl"><code class="literal">python -m SimpleHTTPServer</code></p>
<p id="and_then_pointi">and then pointing your web browser at <a class="ulink" href="http://localhost:8000/" target="_top">http://localhost:8000/</a>. There is great tech tip on this feature at the Linux Journal web site at</p>
<p id="para_id3"><a class="ulink" href="http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python" target="_top">http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python</a>.</p>
</div>
<p id="the_full_code_f">The full code for this example is in file <code class="filename">Chapter 2/example2-3.html.</code> <a class="xref" href="ch02.html#creating_a_texture_map_from_an_image" title="Example 2-11. Creating a Texture Map from an Image">Example 2-11</a> shows the code for loading the texture. First, we call <code class="literal">gl.createTexture()</code> to create a new WebGL texture object. Then we set the <code class="literal">image</code> property of the texture to a newly created <code class="literal">Image</code> object. Finally, we set the <code class="literal">src</code> property of the image to load a JPEG file, in this case a 256-pixel square version of the official WebGL logo; but before doing that we register an event handler for image’s <code class="literal">onload</code> event. We do that because we have to do a few more things with the WebGL texture object once the image is loaded.</p>
<p id="in_handletextur">In <code class="literal">handleTextureLoaded()</code>, we do several things. [EXPLAIN BIND TEXTURE]The first one is pretty interesting: we call <code class="literal">gl.pixelStorei()</code> to flip the Y values of all of the pixels in the texture, because in WebGL, texture coordinates increase as Y goes up the screen, whereas web image formats natively store pixel Y values going downward. [EXPLAIN THE OTHER PARAMS]. Finally, we set our <code class="literal">okToRun</code> global to true, which will tell the <code class="literal">run()</code> function that we now have a valid texture and therefore it is ok to call the drawing code.</p>
<div class="example" id="creating_a_texture_map_from_an_image">
<div class="example-title">Example 2-11. Creating a Texture Map from an Image</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_oktorun__f">   <code class="kd">var</code> <code class="nx">okToRun</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">handleTextureLoaded</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">texture</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">texture</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">pixelStorei</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">UNPACK_FLIP_Y_WEBGL</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">texImage2D</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">RGBA</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">RGBA</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">UNSIGNED_BYTE</code><code class="p">,</code> <code class="nx">texture</code><code class="p">.</code><code class="nx">image</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">texParameteri</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_MAG_FILTER</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">NEAREST</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">texParameteri</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_MIN_FILTER</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">NEAREST</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
        <code class="nx">okToRun</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">var</code> <code class="nx">webGLTexture</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">initTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>
     <code class="nx">webGLTexture</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createTexture</code><code class="p">();</code>
     <code class="nx">webGLTexture</code><code class="p">.</code><code class="nx">image</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Image</code><code class="p">();</code>
     <code class="nx">webGLTexture</code><code class="p">.</code><code class="nx">image</code><code class="p">.</code><code class="nx">onload</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
            <code class="nx">handleTextureLoaded</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">webGLTexture</code><code class="p">)</code>
        <code class="p">}</code>

     <code class="nx">webGLTexture</code><code class="p">.</code><code class="nx">image</code><code class="p">.</code><code class="nx">src</code> <code class="o">=</code> <code class="s2">"../images/webgl-logo-256.jpg"</code><code class="p">;</code>
    <code class="p">}</code></pre></div>
</div>
<p id="as_usual_we_al">As usual, we also have to adapt a few other sections of the code: the buffer creation, the shader, and the part of the drawing code that populates the shader values. First, we replace the code that created a buffer of color information with code that creates a buffer of <span class="emphasis"><em>texture coordinates</em></span>. Textures coordinates are floating-point pairs defined at each vertex, with values typical ranging from 0 to 1. These values represent x, y offsets into the bitmap image data; the shader will use these values to get pixel information from the bitmap as we shall see in the shader code momentarily. Texture coordinate values for our cube are pretty easy: each face uses the entire texture, so the values for any corner of the cube face are at a corner of the texture, e.g. [0, 0], [0, 1], [1, 0] or [1, 1]. <a class="xref" href="ch02.html#buffer_creation_code_for_texture-mapped" title="Example 2-12. Buffer Creation Code for Texture-Mapped Cube">Example 2-12</a> shows the code to create the texture coordinate buffer.</p>
<div class="example" id="buffer_creation_code_for_texture-mapped">
<div class="example-title">Example 2-12. Buffer Creation Code for Texture-Mapped Cube</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_texcoordbuf">       <code class="kd">var</code> <code class="nx">texCoordBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">texCoordBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">textureCoords</code> <code class="o">=</code> <code class="p">[</code>
          <code class="c1">// Front face</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>

          <code class="c1">// Back face</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>

          <code class="c1">// Top face</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>

          <code class="c1">// Bottom face</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>

          <code class="c1">// Right face</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>

          <code class="c1">// Left face</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
        <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">textureCoords</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code></pre></div>
</div>
<p id="id_d1e5799">The shader code must be modified to use texture information instead of colors. The vertex shader defines a <code class="literal">texCoord</code> vertex attribute that is passed with the vertex data, and a varying output, <code class="literal">vTexCoord</code>, which will be sent to the fragment shader for each vertex. The fragment shader then uses this texture coordinate as an index into the texture map data, which is passed as a uniform to the fragment shader in the variable <code class="literal">uSampler</code>. The pixel data is retrieved from the texture using a GLSL function called <code class="literal">texture2D()</code>, which takes sampler and a 2D vector x, y position. The updated shader code is shown in <a class="xref" href="ch02.html#shader_code_for_texture-mapped_cube" title="Example 2-13. Shader Code for Texture-Mapped Cube">Example 2-13</a>.</p>
<div class="example" id="shader_code_for_texture-mapped_cube">
<div class="example-title">Example 2-13. Shader Code for Texture-Mapped Cube</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_vertexshade_id2">    <code class="kd">var</code> <code class="nx">vertexShaderSource</code> <code class="o">=</code>

        <code class="s2">"    attribute vec3 vertexPos;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    attribute vec2 texCoord;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    uniform mat4 modelViewMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 projectionMatrix;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    varying vec2 vTexCoord;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"        // Return the transformed and projected vertex value\n"</code> <code class="o">+</code>
        <code class="s2">"        gl_Position = projectionMatrix * modelViewMatrix * \n"</code> <code class="o">+</code>
        <code class="s2">"            vec4(vertexPos, 1.0);\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"        // Output the texture coordinate in vTexCoord\n"</code> <code class="o">+</code></strong></span>
        <code class="err">"</code>        <span class="strong"><strong><code class="nx">vTexCoord</code> <code class="o">=</code> <code class="nx">texCoord</code><code class="p">;</code><code class="err">\</code><code class="nx">n</code><code class="err">"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    }\n"</code><code class="p">;</code>

    <code class="kd">var</code> <code class="nx">fragmentShaderSource</code> <code class="o">=</code>
        <code class="s2">"    precision mediump float;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    varying vec2 vTexCoord;\n"</code> <code class="o">+</code></strong></span>
        <span class="strong"><strong><code class="s2">"    uniform sampler2D uSampler;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"    // Return the pixel color: always output white\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    gl_FragColor = texture2D(uSampler, vec2(vTexCoord.s, vTexCoord.t));\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"}\n"</code><code class="p">;</code></pre></div>
</div>
<p id="as_our_final_st">As our final step in getting textures onto our cube, we have to modify the drawing function a little. <a class="xref" href="ch02.html#example_caption_text_goes_here" title="Example 2-14. Example Caption Text Goes Here">Example 2-14</a> shows the modified code. We replace the color buffer setup code with code that sets up the texture coordinate buffer. We also set the texture to be used and connect it to the shader inputs. (As with shaders and other state in the WebGL API, there is a notion of the current, or “active” texture.) At long last, our cube is ready to draw with <code class="literal">gl.drawElements()</code>.</p>
<div class="example" id="example_caption_text_goes_here">
<div class="example-title">Example 2-14. Example Caption Text Goes Here</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="glvertexattrib">        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderTexCoordAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">texCoordSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">indices</code><code class="p">);</code></strong></span>

        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">projectionMatrix</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderModelViewMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">);</code>

        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">activeTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE0</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">webGLTexture</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">uniform1i</code><code class="p">(</code><code class="nx">shaderSamplerUniform</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span></pre></div>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="chapter_summary">
<div class="titlepage"><div><div><h2 class="title">Chapter Summary</h2></div></div></div>
<p id="this_chapter_sh">This chapter showed us how to use the WebGL API to render graphics. We went through the basics of setting up a WebGL application, including creating a context, viewports, buffers, matrices, shaders and drawing primitives. We explored how to create 2D and 3D geometry and paint it with colors and bitmap textures. We even got a little help from open source libraries <code class="literal">glMatrix</code> and <code class="literal">RequestAnimationFrame</code>, two staples of WebGL development.</p>
<p id="it_should_be_ap">It should be apparent by now that WebGL programming, at its lowest level, is a lot of work. We were able to get somewhat complex geometry with colors and textures moving around on the page; however it took hundreds of lines of code. There is huge power in there—you can do practically anything you can imagine to every vertex and pixel on the screen, at blinding, hardware-accelerated speeds. But it requires heavy lifting. The designers of the standard made a conscious decision to trade size for power. The API is small and simple, at the cost of having to do a lot of coding on the application side.</p>
<p id="if_youre_an_ex">If you’re an experienced game or graphics programmer and you want to have fine control over the performance and feature set of your application, working directly with the WebGL API might be right for you. If you are building an application with very specific rendering requirements, say an image-processing application or 3D modeling tool, staying close to the WebGL metal is probably your best option. You will still probably want to build some abstractions on top—nobody wants to write the same 40 lines of code over and over again to create a cube, for example—but that layer will be all your own and you will know and control every line of code.</p>
<p id="however_if_you">However, if you are a mere mortal like most of us, you will want to work at a higher level than WebGL, hopefully by using tools that have already been developed. The good news is that several already exist: there are some great open source libraries built on top of WebGL. We will be exploring them in the next several chapters. Let’s get to it.</p>
</div></section><section class="preface" data-original-filename="ch00.xml" id="preface"><div class="titlepage"><div><div><h1 class="title">Preface</h1></div></div></div>
<p id="in_its_roughly_">In its roughly twenty years of existence, 3D on the web has taken a tortuous journey. In 1994 it was a Next Big Thing called <span class="emphasis"><em>VRML</em></span> that grabbed industry attention, only to ultimately become a bastard stepchild of mainstream web development during the first Internet boom. Around 2000, a new Next Big Thing called <span class="emphasis"><em>Shockwave 3D</em></span> promised to democratize game development; by 2004, that offspring was also shipped off to the orphanage. In 2007, the virtual world system <span class="emphasis"><em>Second Life</em></span> leapfrogged the technology media establishment, landing on the cover of <span class="emphasis"><em>BusinessWeek</em></span>, and a new 3D land grab ensued— literally, as folks rented Second Life islands in droves attempting to colonize a cyberspace that never quite materialized. By 2010, virtual worlds were yesterday’s news, as consumers latched on to social and mobile gaming to sate their appetite for distraction. Viewed through one lens, this is a litany of failure. Viewed through another, it is a crucible.</p>
<p id="good_ideas_may_">Good ideas may take a long time, but they never truly die. 3D on the web is one such idea.  Once you look past the well meaning but naïve overreaches of the earlier attempts, you can see what some of us (in all humility) have known all along: 3D is just another media type. Whether you use it to build an architectural walkthrough, a virtual world, a molecular model, or any of a host of other applications, 3D is just another way to get pixels moving on a screen at the behest of the user. Thankfully, the latest generations of browser makers get this, and have been slowly and steadfastly turning the web browser into rich media development platform that includes first-rate, hardware-accelerated graphics and a well thought out compositing architecture. Put in less flowery words: 3D is here; get used to it.</p>
<p id="this_book_is_in">This book is intended to provide you with the information you need to create production-quality 3D applications for desktop and mobile browsers using 3D technologies available in modern browsers: WebGL, Canvas, and CSS. It covers related topics such as JavaScript performance, Web Workers and high performance web design; and it goes deep into tools and libraries that will help make you productive: Three.js, Tween.js, and the many options for 3D content creation and conversion.</p>
<p id="you_are_holding">You are holding in your hands the Early Release of my new book. It is about 40 percent complete. By being part of the Early Release program, you will see new chapters hot off the press— be that for good or ill. I like to think that this is the beginning of a partnership between us. If there is something you like, let me know. Conversely, critical feedback is also welcome, and your early participation promises to make this a stronger title. The accompanying table of contents gives a sense of exactly what the book is going to include, but it is still preliminary.</p>
<p id="readers_of_my_f">Readers of my first book, <span class="emphasis"><em>WebGL: Up and Running</em></span>, will see a fair amount of overlap between that book and the early chapters of this one. This is unavoidable. Much of the material in the early chapters is overview and introductory; as such it must stand on its own without requiring readers to get the earlier book. Regardless, despite the superficial similarities in the early chapters, readers of the first book will find much additional information. Even the introductory chapters here go far deeper into the material than the first book could afford, given its mission. And once we get past the first five chapters, the material is almost completely different. <span class="emphasis"><em>WebGL: Up and Running</em></span> was intended to provide readers with an approachable introduction to a new and daunting subject. I like to think that what it lacked in technical rigor, it made up for in enthusiasm; if you came away reading it with nothing other than an appetite to learn more, I consider my job well done. On the other hand, this book aims to give readers a thorough grounding in both theory and practice, allowing them to emerge from the experience ready to build production 3D applications.</p>
<div class="sect1" data-original-filename="ch00.xml" id="audience">
<div class="titlepage"><div><div><h2 class="title">Audience</h2></div></div></div>
<p id="this_book_was_w">This book was written for experienced web developers looking to move into 3D development. It assumes that you are an intermediate level developer with a solid grounding in HTML, CSS, and JavaScript, and at least working familiarity with jQuery. You do not need 3D graphics or animation experience, though it will be helpful. The book provides a basic 3D primer, and explains additional concepts as needed throughout.</p>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="how_this_book_is_organized">
<div class="titlepage"><div><div><h2 class="title">How This Book Is Organized</h2></div></div></div>
<p id="this_book_is_di">This book is divided into two parts:</p>
<p id="part_i__founda"><span class="emphasis"><em>Part I – Foundations</em></span> explores the underlying HTML5 APIs and technologies for creating 3D web graphics, including WebGL, Canvas, and CSS3. It also covers the open source libraries, frameworks and production tools needed to build applications.</p>
<div class="itemizedlist" id="chapter__provi_id1"><ul class="itemizedlist">
<li class="listitem"><p id="chapter__provi_id2"><span class="emphasis"><em>Chapter 1</em></span> provides an introduction to 3D application development and core 3D graphics concepts.</p></li>
<li class="listitem"><p id="chapters__thro"><span class="emphasis"><em>Chapters 2 through 5</em></span> dive into WebGL, covering the built-in API as well as two popular open-source libraries used to develop graphics and animation: Three.js and Tween.js.</p></li>
<li class="listitem"><p id="chapter__explo"><span class="emphasis"><em>Chapter 6</em></span> explores the new features of CSS3 used in 3D development.</p></li>
<li class="listitem"><p id="chapter__descr"><span class="emphasis"><em>Chapter 7</em></span> describes the 2D Canvas API, and how it can be used to emulate 3D effects on resource-challenged platforms.</p></li>
<li class="listitem"><p id="chapter__cover"><span class="emphasis"><em>Chapter 8</em></span> covers the 3D content creation pipeline—the tools and file formats used by artists to create 3D models and animations.</p></li>
</ul></div>
<p id="part_ii__appli"><span class="emphasis"><em>Part II - Application Development Techniques</em></span> goes hands-on into several practical application development topics.</p>
<div class="itemizedlist" id="chapter__looks_id1"><ul class="itemizedlist">
<li class="listitem"><p id="chapter__looks_id2"><span class="emphasis"><em>Chapter 9</em></span> looks at how to use frameworks to accelerate 3D development and introduces Vizi, an open source framework for creating reusable 3D components.</p></li>
<li class="listitem"><p id="chapters__thr"><span class="emphasis"><em>Chapters 10 through 13</em></span> look into developing specific aspects of 3D applications: 3D user interface; simple environments for single-model; complex 3D environments; and integrating 2D and 3D into seamless presentations.</p></li>
<li class="listitem"><p id="chapters__and"><span class="emphasis"><em>Chapters 14 and 15</em></span> cover topics related to production 3D deployment: mobile development and performance.</p></li>
<li class="listitem"><p id="chapter__expl"><span class="emphasis"><em>Chapter 16</em></span> explores application case studies that combine various techniques from the book.</p></li>
</ul></div>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="conventions_used_in_this_book">
<div class="titlepage"><div><div><h2 class="title">Conventions Used in This Book</h2></div></div></div>
<p id="the_following_t">The following typographical conventions are used in this book:</p>
<div class="variablelist" id="italicindicates"><dl class="variablelist">
<dt><span class="term"><span class="emphasis"><em>Italic</em></span></span></dt>
<dd><p id="indicates_new_t">Indicates new terms, URLs, email addresses, filenames, and file extensions</p></dd>
<dt><span class="term"><code class="literal">Constant width</code></span></dt>
<dd><p id="used_for_progra">Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords</p></dd>
<dt><span class="term"><strong class="userinput"><code>Constant width bold</code></strong></span></dt>
<dd><p id="shows_commands_">Shows commands or other text that should be typed literally by the user</p></dd>
<dt><span class="term"><em class="replaceable"><code>Constant width italic</code></em></span></dt>
<dd><p id="shows_text_that">Shows text that should be replaced with user-supplied values or by values determined by context</p></dd>
</dl></div>
<div class="note" id="this_icon_signi_id1"><p id="this_icon_signi_id2">This icon signifies a tip, suggestion, or general note.</p></div>
<div class="warning" id="this_icon_indic_id1"><p id="this_icon_indic_id2">This icon indicates a warning or caution.</p></div>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="this_books_example_files">
<div class="titlepage"><div><div><h2 class="title">This Book’s Example Files</h2></div></div></div>
<p id="you_can_downloa">You can download all of the code examples for this book from GitHub at the following location:</p>
<table style="border: 0; " class="simplelist"><tr><td><a class="ulink" href="https://github.com/tparisi/Programming3DApplications" target="_top">https://github.com/tparisi/Programming3DApplications</a></td></tr></table>
<p id="in_the_example_">In the example files you will find the completed versions of the applications built in the book, which will contain all the code required to run them. In a few cases you will need to download additional content files, such as 3D models, from their original sites before running the application; consult the README file in the top-level folder for details.</p>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="using_code_examples">
<div class="titlepage"><div><div><h2 class="title">Using Code Examples</h2></div></div></div>
<p id="this_book_is_he">This book is here to help you get your job done. In general, you may use the code in this book in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p>
<p id="we_appreciate_">We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<span class="emphasis"><em>Programming 3D Applications with HTML5 and WebGL</em></span> by Tony Parisi (O’Reilly). Copyright 2013 Tony Parisi, 978-1-449-36296-6.”</p>
<p id="if_you_feel_you">If you feel your use of code examples falls outside fair use or the permission given here, feel free to contact us at <code class="email">&lt;<a class="email" href="mailto:permissions@oreilly.com">permissions@oreilly.com</a>&gt;</code>.</p>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="safari_books_online">
<div class="titlepage"><div><div><h2 class="title">Safari® Books Online</h2></div></div></div>
<div class="note safaribooksonline" id="safari_books_on_id1"><p id="safari_books_on_id2">Safari Books Online (<a class="ulink" href="http://my.safaribooksonline.com/?portal=oreilly" target="_top">www.safaribooksonline.com</a>)
      is an on-demand digital library that delivers expert <a class="ulink" href="http://www.safaribooksonline.com/content" target="_top">content</a> in both
      book and video form from the world’s leading authors in technology and
      business.</p></div>
<p id="technology_prof">Technology professionals, software developers, web designers, and
    business and creative professionals use Safari Books Online as their
    primary resource for research, problem solving, learning, and
    certification training.</p>
<p id="safari_books_on_id3">Safari Books Online offers a range of <a class="ulink" href="http://www.safaribooksonline.com/subscriptions" target="_top">product mixes</a>
    and pricing programs for <a class="ulink" href="http://www.safaribooksonline.com/organizations-teams" target="_top">organizations</a>,
    <a class="ulink" href="http://www.safaribooksonline.com/government" target="_top">government
    agencies</a>, and <a class="ulink" href="http://www.safaribooksonline.com/individuals" target="_top">individuals</a>.
    Subscribers have access to thousands of books, training videos, and
    prepublication manuscripts in one fully searchable database from
    publishers like O’Reilly Media, Prentice Hall Professional, Addison-Wesley
    Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press,
    Cisco Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM
    Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders,
    McGraw-Hill, Jones &amp; Bartlett, Course Technology, and dozens <a class="ulink" href="http://www.safaribooksonline.com/publishers" target="_top">more</a>. For more
    information about Safari Books Online, please visit us <a class="ulink" href="http://www.safaribooksonline.com/" target="_top">online</a>.</p>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="how_to_contact_us">
<div class="titlepage"><div><div><h2 class="title">How to Contact Us</h2></div></div></div>
<p id="please_address_">Please address comments and questions concerning this book to the
    publisher:</p>
<table style="border: 0; " class="simplelist">
<tr><td>O’Reilly Media, Inc.</td></tr>
<tr><td>1005 Gravenstein Highway North</td></tr>
<tr><td>Sebastopol, CA 95472</td></tr>
<tr><td>800-998-9938 (in the United States or Canada)</td></tr>
<tr><td>707-829-0515 (international or local)</td></tr>
<tr><td>707-829-0104 (fax)</td></tr>
</table>
<p id="we_have_a_web_p">We have a web page for this book, where we list errata, examples,
    and any additional information. You can access this page at <a class="ulink" href="http://shop.oreilly.com/product/0636920029205.do" target="_top">http://shop.oreilly.com/product/0636920029205.do</a>.</p>
<p id="to_comment_or_a">To comment or ask technical questions about this book, send email to
    <code class="email">&lt;<a class="email" href="mailto:bookquestions@oreilly.com">bookquestions@oreilly.com</a>&gt;</code>.</p>
<p id="for_more_inform">For more information about our books, courses, conferences, and
    news, see our website at <a class="ulink" href="http://www.oreilly.com" target="_top">http://www.oreilly.com</a>.</p>
<p id="find_us_on_face">Find us on Facebook: <a class="ulink" href="http://facebook.com/oreilly" target="_top">http://facebook.com/oreilly</a></p>
<p id="follow_us_on_tw">Follow us on Twitter: <a class="ulink" href="http://twitter.com/oreillymedia" target="_top">http://twitter.com/oreillymedia</a></p>
<p id="watch_us_on_you">Watch us on YouTube: <a class="ulink" href="http://www.youtube.com/oreillymedia" target="_top">http://www.youtube.com/oreillymedia</a></p>
</div>
<div class="sect1" data-original-filename="ch00.xml" id="acknowledgments">
<div class="titlepage"><div><div><h2 class="title">Acknowledgments</h2></div></div></div>
<p id="para_id1"></p>
</div></section><section class="chapter" data-original-filename="ch01.xml" id="introduction"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Introduction</h1></div></div></div>
<p id="we_live_in_a_d">We live in a 3D world. People move, think and experience in three dimensions.</p>
<p id="much_of_our_med">Much of our media is also 3D— though it is usually presented on flat screens. Animated films are created from computer-generated 3D images. Online map services allow us to explore our destination, virtually, in a 3D environment. Most video games, whether running on dedicated consoles or mobile phones, are rendered in 3D. Even the news has gone 3D: the sight of a CNN analyst meandering through a virtual set, comically awkward a few years ago, has become an accepted part of the broadcast vocabulary as cable channels vie for increasing attention in a twenty-four hour news cycle.</p>
<p id="d_graphics_is_">3D graphics is nearly as old as the computer itself, tracing its roots back to the 1960’s. It has been used in applications spanning engineering, education, training, architecture, finance, sales and marketing, gaming and entertainment. Historically, 3D applications have relied on high-end computer systems and expensive software. But that has changed in the last decade. 3D processing hardware is now shipped in every computer and mobile device, with the consumer smart phone of today possessing more graphics power than the professional workstation of fifteen years before. More importantly, the software required to render 3D is now not only universally accessible; it’s free. It’s called a web browser.</p>
<p id="shows_an_excerp"><a class="xref" href="ch01.html#the_100_comma_000_stars_project_by_googl" title="Figure 1-1. The 100,000 Stars project by Google ()">Figure 1-1</a> shows an excerpt from <span class="emphasis"><em>100,000 Stars</em></span>, a browser-based 3D flythrough simulation of our stellar neighbors in the Milky Way. Using the mouse, you can rotate about the galactic plane and zoom in to a star of interest. Stars are represented with renderings that approximate their apparent magnitude and color. Each star is labeled with its common name; when you mouse over the label, it highlights. Click on the label, and an overlay appears displaying the Wikipedia entry for that star. Click on a hyperlink in the overlay text, and the browser will launch that link in a new tab. <span class="emphasis"><em>100,000 Stars</em></span> is a stunningly produced interactive experience featuring beautiful renderings, pulsing animations, a majestic soundtrack, and an artfully integrated 2D user interface.</p>
<div class="figure" id="the_100_comma_000_stars_project_by_googl">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-1.png" alt="The 100,000 Stars project by Google ()"></div></div>
<div class="figure-title">Figure 1-1. The 100,000 Stars project by Google (<a class="ulink" href="http://workshop.chromeexperiments.com/stars/" target="_top">http://workshop.chromeexperiments.com/stars/</a>)</div>
</div>
<p id="stars_w"><span class="emphasis"><em>100,000 Stars</em></span> was created as an experiment by Google’s Data Arts Team to demonstrate the rich capabilities of the Chrome browser. While the application is experimental, the technologies underlying it are not: it was built using HTML5 features available today in most browsers. The galaxy and stars are rendered in real-time using WebGL, the new standard for hardware-accelerated 3D web graphics; the labels are placed relative to their stars using 3D transforms now available in CSS3; and the overlays blend seamlessly with the 3D content because browsers combine, or <span class="emphasis"><em>composite</em></span>, all page elements into a unified presentation.</p>
<p id="just_a_few_year">Just a few years ago, an experience like <span class="emphasis"><em>100,000 Stars</em></span> could only have been achieved in a native client application requiring a large download and installation, produced using complex tools in a time-consuming and expensive development process. Today, it can be built using a browser, free and open source tools, and a standard web technology stack. What’s more, updates are instantly available by simply reloading the page; information from anywhere on the web can be loaded via URL; and hyperlinks from the 3D can take you to more information.</p>
<p id="this_book_is_ab">This book is about taking advantage of the awesome power of the modern browser to create a new breed of connected, visual application. Some of this breed will look a lot like its ancestors, essentially ports of traditional 3D products, refactored to reach new customers and reduce costs. But far more exciting are the possibilities for novel consumer applications in advertising, product marketing, customer support, education, training, tourism, gaming and entertainment-- to name a few. 3D brings a new dimension to the interactive experience; combined with web technology, the third dimension is now accessible to everyone on the planet.</p>
<div class="note" id="stars_i_id1">
<p id="stars_i_id2"><span class="emphasis"><em>100,000 Stars</em></span> is a tour de force in interactive media development. Michael Chang, one of the creators, wrote a great case study of the project. To see what went into its development, go to</p>
<p id="para_id2"><a class="ulink" href="http://www.html5rocks.com/en/tutorials/casestudies/100000stars/" target="_top">http://www.html5rocks.com/en/tutorials/casestudies/100000stars/</a></p>
</div>
<div class="sect1" data-original-filename="ch01.xml" id="html5_colon_a_new_visual_medium">
<div class="titlepage"><div><div><h2 class="title">HTML5: A New Visual Medium</h2></div></div></div>
<p id="html_has_come_a">HTML has come a long way since the days of static pages, forms and the Submit button. In the early 2000’s browsers introduced rich interaction by allowing portions of a page to be changed dynamically via Ajax techniques. Still, the ways in which pages could be changed with Ajax were constrained by the graphical features of HTML and CSS. If a developer wished to go beyond those limits, they had to use media plugins such as Flash and QuickTime.</p>
<p id="this_was_pretty">This was pretty much the status quo during the 2000’s, but things have changed over the last few years. Several browser advances under development during this period came together into HTML5. With HTML5, the web browser has become a platform capable of running sophisticated applications that rival native code in features and performance. HTML5 represents a massive overhaul to the HTML standard, including syntax cleanups, new JavaScript language features and APIs, mobile capabilities, and breakthrough multimedia support. Central to the HTML5 platform is a set of advanced graphics technologies that are the focus of this book:</p>
<div class="itemizedlist" id="webgl_for_hardw_id1"><ul class="itemizedlist">
<li class="listitem"><p id="webgl_for_hardw_id2"><span class="strong"><strong>WebGL</strong></span> for hardware-accelerated 3D rendering with JavaScript. Based on the time-tested graphics API OpenGL, WebGL is a standard supported by nearly all web browsers on the desktop as well as a growing number of mobile browsers.</p></li>
<li class="listitem"><p id="css_d_transfo"><span class="strong"><strong>CSS3 3D</strong></span> transforms, transitions and custom filters for advanced page effects. CSS has evolved over the past several years to include 3D rendering and animation features accessible through style sheet language.</p></li>
<li class="listitem"><p id="the_canvas_elem"><span class="strong"><strong>The Canvas Element</strong></span> and its 2D drawing context API. Universally supported in browsers, this JavaScript API allows developers to draw arbitrary graphics to the surface of a DOM element. Though Canvas is a 2D API, with the help of additional JavaScript libraries it can be used to render 3D effects—providing an alternative for platforms where WebGL or CSS3 3D are not supported.</p></li>
</ul></div>
<p id="each_of_these_f">Each of these features has its strengths, weaknesses and technical tradeoffs, and each has a role to play in delivering interactive and visually compelling 3D experiences. Which ones you use can depend on several factors—what you are trying to build, which platforms you have to support, performance concerns and so on. Let say, for example, that you are creating a first-person shooter game and you need the highest-quality graphics. This will be hard to pull off without using WebGL’s extensive access to the rendering hardware. On the other hand, maybe you are developing a fancy channel tuner interface for a video web site, including live video thumbnails, rotation effects on rollovers, and dissolve transitions between clips; in that case CSS3 might have everything you need to deliver a killer experience.</p>
<div class="note" id="and_one_standa_id1">
<p id="and_one_standa_id2"><span class="emphasis"><em>“And one standard to rule them all...”</em></span></p>
<p id="what_most_web_d">What most web developers think of informally as HTML5 is actually a collection of technologies and standards. Some of these are already fully ratified by the W3C and implemented in all browsers. Others are less mature as standards, but nevertheless widely supported. Still others, such as WebGL, are mature and stable standards, but not controlled by the W3C.</p>
</div>
</div>
<div class="sect1" data-original-filename="ch01.xml" id="the_browser_as_platform">
<div class="titlepage"><div><div><h2 class="title">The Browser as Platform</h2></div></div></div>
<p id="html_brings_ri">HTML5 brings rich graphics to the web; by itself this would not amount to much without the presence of other essential browser improvements. In particular, a handful of advances have paved the way for true rich Internet application development with HTML5:</p>
<div class="itemizedlist" id="javascript_virt_id1"><ul class="itemizedlist">
<li class="listitem"><p id="javascript_virt_id2"><span class="strong"><strong>JavaScript Virtual Machine (VM) Performance</strong></span>. WebGL and Canvas 2D are JavaScript APIs; animation and interaction will only run as fast as the JavaScript code behind it. A few years ago, virtual machine performance would have made 3D development a non-starter for practical use. Thankfully, today’s VMs scream.</p></li>
<li class="listitem"><p id="accelerated_com"><span class="strong"><strong>Accelerated Compositing</strong></span>. The browser is responsible for combining, or <span class="emphasis"><em>compositing</em></span>, the various elements on the page quickly and without visual tearing or other adverse effects. As content has become more dynamic, browsers have made huge improvements in compositing, including using the 3D hardware-rendering pipeline for all visual elements, both 2D and 3D.</p></li>
<li class="listitem"><p id="animation_suppo"><span class="strong"><strong>Animation Support</strong></span>. The function <code class="literal">requestAnimationFrame()</code> was introduced as an alternative to using <code class="literal">setInterval()</code> or <code class="literal">setTimeout()</code> to drive animations— greatly enhancing performance and eliminating visual artifacts.</p></li>
</ul></div>
<p id="html_browsers_">HTML5 browsers also include features for multi-threaded programming (<span class="emphasis"><em>Web Workers</em></span>), full duplex TCP/IP networking (<span class="emphasis"><em>WebSockets</em></span>), local data storage, and more that developers can use to deliver world-class application functionality. These features, taken together with WebGL, CSS3 3D and the Canvas, represent a revolutionary new <span class="emphasis"><em>platform</em></span> for delivering connected visual applications on any computer or device.</p>
<p id="shows_a_demonst"><a class="xref" href="ch01.html#epic_citadel_demonstration_running_in_fi" title="Figure 1-2. Epic Citadel Demonstration Running in Firefox: 60FPS Browser Gaming Powered by WebGL and asm.js">Figure 1-2</a> shows a demonstration version of Epic Games’ <span class="emphasis"><em>Epic Citadel</em></span> running (as of this writing) in a development build of Firefox. <span class="emphasis"><em>Epic Citadel</em></span> uses WebGL to render the graphics, but what really sets this work apart is the breakthrough in game engine performance. The game uses a version of Epic’s <span class="emphasis"><em>Unreal</em></span> engine that has been ported from its native C++/operating system-dependent code to a browser-based implementation, using the <span class="emphasis"><em>Emscripten</em></span> compiler (<a class="ulink" href="https://github.com/kripken/emscripten/wiki" target="_top">https://github.com/kripken/emscripten/wiki</a>) and asm.js, a new optimized low-level subset of JavaScript. By simply entering a URL, web browser users can access a beautifully rendered, full screen console game experience running at 60 frames per second, with very little download time and no installation required.</p>
<div class="figure" id="epic_citadel_demonstration_running_in_fi">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-2.png" alt="Epic Citadel Demonstration Running in Firefox: 60FPS Browser Gaming Powered by WebGL and asm.js"></div></div>
<div class="figure-title">Figure 1-2. Epic Citadel Demonstration Running in Firefox: 60FPS Browser Gaming Powered by WebGL and <span class="emphasis"><em>asm.js</em></span>
</div>
</div>
<div class="sect2" id="browser_realities">
<div class="titlepage"><div><div><h3 class="title">Browser Realities</h3></div></div></div>
<p id="as_of_this_writ">As of this writing, 3D feature coverage is not complete across the various browsers. Worse, each browser supports a slightly different subset. We will explore these issues in detail in subsequent chapters, but here are the highlights:</p>
<div class="itemizedlist" id="webgl_is_suppor_id1"><ul class="itemizedlist">
<li class="listitem"><p id="webgl_is_suppor_id2">WebGL is supported in all desktop browsers with the exception of Internet Explorer (which currently represents under 30% market share and shrinking); however, word has leaked to the public that Microsoft has implemented WebGL for IE internally and will ship it sometime in 2013;</p></li>
<li class="listitem"><p id="webgl_is_fully_">WebGL is fully supported in mobile Chrome, Intel Tizen and the Blackberry 10 browser. WebGL is supported in a limited fashion in mobile Safari (in the iAds framework);</p></li>
<li class="listitem"><p id="css_custom_filt">CSS Custom Filters are only supported experimentally in desktop Chrome, Safari, mobile Safari and Blackberry 10 — not in IE or Firefox.</p></li>
</ul></div>
<p id="clearly_this_i">Clearly, this is not an optimal situation, but it’s the sort of thing that comes with the territory when developing web applications. Cross-browser support has always been notoriously difficult; with the explosion of features in HTML5 and the proliferation of devices and operating systems, it hasn’t gotten any better. The only consolation is that the alternative is far worse: native applications are even harder to build, test, deploy and port. Oh well... such is the life of a web developer in the twenty-first century.</p>
<div class="note" id="with_all_these__id1"><p id="with_all_these__id2">With all these standards, we should be approaching a state where we only have to write our code once. However, as we have become painfully aware, the mantra “write once—run anywhere,” has been replaced by the lament, “write once—debug everywhere.”</p></div>
</div>
</div>
<div class="sect1" data-original-filename="ch01.xml" id="d_graphics_basics">
<div class="titlepage"><div><div><h2 class="title">3D Graphics Basics</h2></div></div></div>
<div class="sect2" id="what_is_3d_question">
<div class="titlepage"><div><div><h3 class="title">What is 3D?</h3></div></div></div>
<p id="given_that_you_">Given that you picked up this book, chances are you have at least an informal idea about what we are talking about when we use the term <span class="emphasis"><em>3D graphics</em></span>. But to make sure we are clear, we are going to get formal and examine a definition. Here is the Wikipedia entry (from <a class="ulink" href="http://en.wikipedia.org/wiki/3D_computer_graphics" target="_top">http://en.wikipedia.org/wiki/3D_computer_graphics</a>).</p>
<div class="blockquote"><blockquote class="blockquote"><p id="d_computer_gra">3D computer graphics (in contrast to 2D computer graphics) are graphics that use a three-dimensional representation of geometric data (often Cartesian) that is stored in the computer for the purposes of performing calculations and rendering 2D images. Such images may be stored for viewing later or displayed in real-time.</p></blockquote></div>
<p id="lets_break_thi">Let’s break this down into its components: 1) the data is represented in a 3D coordinate system; 2) it is ultimately drawn (“rendered”) as a 2D image, for example, on your computer monitor; and 3) it can be displayed in real-time: when the 3D data changes as it is being animated or manipulated by the user, the rendered image is updated without a perceivable delay. This last part is key for creating interactive applications. In fact, it is so important that it has spawned a multi-billion dollar industry dedicated to specialized graphics hardware supporting real-time 3D rendering, with several companies you have probably heard of such NVIDIA, ATI, and Qualcomm leading the charge.</p>
<p id="as_important_as">As important as what this definition says is what it doesn’t say: 3D graphics does not require special input hardware like trackballs and joysticks—though those can greatly enhance a 3D experience. Nor does it require custom display hardware: no stereo glasses required; no OmniMax theatre tickets as the price of entry. 3D graphics are most commonly rendered on a flat, 2D display. This is not to say that 3D can’t be displayed in stereo and seen with glasses or on a stereo TV— simply that it’s not a requirement.</p>
<p id="d_programming_">3D programming requires new skills and knowledge beyond that of the typical web developer. However, armed with a little starter knowledge and the right tools, we can get going fairly quickly. The remainder of this chapter is devoted to understanding basic 3D programming concepts that will be used throughout the book. It is by no means exhaustive—entire books are devoted to learning the subject in detail—but it should be enough to get started. If you already have experience with 3D programming, feel free to move on to <a class="xref" href="ch02.html" title="Chapter 2. WebGL: Real-time 3D Rendering">Chapter 2</a>.</p>
</div>
<div class="sect2" id="d_coordinate_systems">
<div class="titlepage"><div><div><h3 class="title">3D Coordinate Systems</h3></div></div></div>
<p id="if_you_are_fami">If you are familiar with 2D Cartesian coordinate systems such as the window coordinates of an HTML document, you know about <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values. These 2D coordinates define where <code class="literal">&lt;div&gt;</code> tags are located on a page, or the where virtual ‘pen’ or ‘brush’ draws in in the HTML Canvas element. Similarly, 3D drawing takes place (not surprisingly) in a 3D coordinate system, where the additional coordinate, <span class="emphasis"><em>z</em></span>, describes depth, i.e. how far into or out of the screen an object is drawn. The coordinate systems we will work with in this book are arranged as depicted in <a class="xref" href="ch01.html#epic_citadel_demonstration_running_in_fi" title="Figure 1-2. Epic Citadel Demonstration Running in Firefox: 60FPS Browser Gaming Powered by WebGL and asm.js">Figure 1-2</a>, with <span class="emphasis"><em>x</em></span> running horizontally left to right, <span class="emphasis"><em>y</em></span> running vertically, and positive <span class="emphasis"><em>z</em></span> coming out of the screen. If you are already comfortable with the concept of the 2D coordinate system, the transition to a 3D coordinate system should be straightforward.</p>
<div class="note" id="note_that_webgl_id1"><p id="note_that_webgl_id2">Note that WebGL defines positive <span class="emphasis"><em>y</em></span> as going from the bottom to the top of the window, while the 2D Canvas API and CSS transforms define positive <span class="emphasis"><em>y</em></span> as going down. This is unfortunate, but it reflects the different heritages of the two technologies: WebGL is based on long-lived graphics standards that use the y-up convention, while Canvas and CSS are based on the HTML coordinate y-down convention—itself a descendant of time-worn window system coordinate schemes. If you end up working in both technologies on a project, you will have to keep this distinction straight. But it could be worse... <span class="emphasis"><em>z</em></span> could also be reversed! Fortunately, it’s not.</p></div>
<div class="figure" id="a_3d_coordinate_system_creative_commons">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-3.png" alt="A 3D Coordinate System Creative Commons Attribution-Share Alike 3.0 Unported License"></div></div>
<div class="figure-title">Figure 1-3. A 3D Coordinate System <a class="ulink" href="https://commons.wikimedia.org/wiki/File:3D_coordinate_system.svg" target="_top">https://commons.wikimedia.org/wiki/File:3D_coordinate_system.svg</a> Creative Commons Attribution-Share Alike 3.0 Unported License</div>
</div>
</div>
<div class="sect2" id="meshes_comma_polygons_and_vertices">
<div class="titlepage"><div><div><h3 class="title">Meshes, Polygons and Vertices</h3></div></div></div>
<p id="while_there_are">While there are several ways to draw 3D graphics, by far the most common is to use a <span class="emphasis"><em>mesh</em></span>. A mesh is an object composed of one or more polygonal shapes, constructed out of <span class="emphasis"><em>vertices</em></span> (x, y, z triples) defining coordinate positions in 3D space. The polygons most typically used in meshes are triangles (groups of three vertices) and quads (groups of four vertices). 3D meshes are often referred to as <span class="emphasis"><em>models</em></span>.</p>
<p id="illustrates_a_"><a class="xref" href="ch01.html#a_3d_coordinate_system_creative_commons" title="Figure 1-3. A 3D Coordinate System Creative Commons Attribution-Share Alike 3.0 Unported License">Figure 1-3</a> illustrates a 3D mesh. The dark lines outline the quads that comprise the mesh, defining the shape of the face. (You would not see these lines in the final rendered image; they are included for reference.) The x, y and z components of the mesh’s vertices define the shape <span class="emphasis"><em>only</em></span>; surface properties of the mesh, such as the color and shading, are defined using additional attributes, as we will discuss below.</p>
<div class="figure" id="a_3d_mesh_creative_commons_attribution">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-4.png" alt="A 3D Mesh Creative Commons Attribution-Share Alike 3.0 Unported license"></div></div>
<div class="figure-title">Figure 1-4. A 3D Mesh <a class="ulink" href="http://upload.wikimedia.org/wikipedia/commons/8/88/Blender3D_UVTexTut1.png" target="_top">http://upload.wikimedia.org/wikipedia/commons/8/88/Blender3D_UVTexTut1.png</a>Creative Commons Attribution-Share Alike 3.0 Unported license</div>
</div>
</div>
<div class="sect2" id="materials_comma_textures_and_lights">
<div class="titlepage"><div><div><h3 class="title">Materials, Textures and Lights</h3></div></div></div>
<p id="the_surface_of_">The surface of a mesh is defined using additional attributes beyond the x, y, and z vertex positions. Surface attributes can be as simple as a single solid color, or they can be complex, comprising several pieces of information that define, for example, how light reflects off the object or how shiny the object looks. Surface information can also be represented using one or more bitmaps, known as <span class="emphasis"><em>texture maps</em></span> (or simply <span class="emphasis"><em>textures</em></span>). Textures can define the literal surface look (such as an image printed on a T-shirt), or they can be combined with other textures to achieve sophisticated effects such as bumpiness or iridescence. In most graphics systems, the surface properties of a mesh are referred to collectively as <span class="emphasis"><em>materials</em></span>. Materials typically rely on the presence of one or more <span class="emphasis"><em>lights</em></span>, which (as you may have guessed) define how a scene is illuminated.</p>
<p id="the_head_in_has">The head in <a class="xref" href="ch01.html#epic_citadel_demonstration_running_in_fi" title="Figure 1-2. Epic Citadel Demonstration Running in Firefox: 60FPS Browser Gaming Powered by WebGL and asm.js">Figure 1-2</a> has a material with a purple color and shading defined by a light source emanating from the left of the model. Note the shadows on the right side of the face.</p>
</div>
<div class="sect2" id="transforms_and_matrices">
<div class="titlepage"><div><div><h3 class="title">Transforms and Matrices</h3></div></div></div>
<p id="d_meshes_are_d">3D meshes are defined by the positions of their vertices. It would get really tedious to change a mesh’s vertex positions every time you want to move it to a different part of the view, especially if the mesh were continually animating. For this reason, most 3D systems support <span class="emphasis"><em>transforms</em></span>, operations that move the mesh by a relative amount without having to loop through every vertex, explicitly changing its position. Transforms allow a rendered mesh to be scaled, rotated and translated (moved) around, without actually changing any values in its vertices.</p>
<p id="a_transform_is_">A transform is typically represented by a <span class="emphasis"><em>matrix</em></span>, a mathematical object containing an array of values used to compute the transformed positions of vertices. If you are a linear algebra geek like me, you probably feel comfortable with this idea. If not, please don’t break into a cold sweat. The toolkits we are using in this book lets us treat matrices like black boxes: we just say translate, rotate or scale and the right thing happens.</p>
</div>
<div class="sect2" id="cameras_comma_perspective_comma_viewport">
<div class="titlepage"><div><div><h3 class="title">Cameras, Perspective, Viewports and Projections</h3></div></div></div>
<p id="every_rendered_">Every rendered scene requires a point of view from which the user will be viewing it. 3D systems typically use a <span class="emphasis"><em>camera</em></span>, an object that defines where (relative to the scene) the user is positioned and oriented, as well as other real-world camera properties such as the size of the field of view, which defines <span class="emphasis"><em>perspective</em></span> (i.e. objects farther away appearing smaller). The camera’s properties combine to deliver the final rendered image of a 3D scene into a 2D <span class="emphasis"><em>viewport</em></span> defined by the window or canvas.</p>
<p id="cameras_are_alm">Cameras are almost always represented using a couple of matrices. The first matrix defines the position and orientation of the camera, much like the matrix used for transforms (see above). The second matrix is a specialized one that represents the translation from the 3D coordinates of the camera into the 2D drawing space of the viewport. It is called the <span class="emphasis"><em>projection matrix</em></span>. I know: more math. But the details of camera matrices are nicely hidden in most tools, so you usually can just point, shoot and render.</p>
<p id="depicts_the_cor"><a class="xref" href="ch01.html#a_3d_mesh_creative_commons_attribution" title="Figure 1-4. A 3D Mesh Creative Commons Attribution-Share Alike 3.0 Unported license">Figure 1-4</a> depicts the core concepts of the camera, viewport and projection. At the lower left we see an icon of an eye; this represents the location of the camera. The red vector pointing to the right (in this diagram labeled as the <code class="literal">X</code> axis) represents the direction in which the camera is pointing. The blue cubes are the objects in the 3D scene. The green and red rectangles are, respectively, the <span class="emphasis"><em>near</em></span> and <span class="emphasis"><em>far clipping planes</em></span>. These two planes define the boundaries of a subset of the 3D space, known as the <span class="emphasis"><em>view volume</em></span> or <span class="emphasis"><em>view frustum</em></span>. Only objects within the view volume are actually rendered to the screen. The near clipping plane is equivalent to the viewport, where we will see the final rendered image.</p>
<div class="figure" id="camera_comma_viewport_and_projection">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-5.png" alt="Camera, Viewport and Projection Reproduced with permission"></div></div>
<div class="figure-title">Figure 1-5. Camera, Viewport and Projection <a class="ulink" href="http://obviam.net/index.php/3d-programming-with-android-projections-perspective/" target="_top">http://obviam.net/index.php/3d-programming-with-android-projections-perspective/</a>Reproduced with permission</div>
</div>
<p id="cameras_are_ext">Cameras are extremely powerful, as they ultimately define the viewer’s relationship to a 3D scene and provide a sense of realism. They also provide another weapon in the animator’s arsenal: by dynamically moving around the camera you can create cinematic effects and control the narrative experience.</p>
</div>
<div class="sect2" id="shaders">
<div class="titlepage"><div><div><h3 class="title">Shaders</h3></div></div></div>
<p id="in_order_to_ren_id1">In order to render the final image for a mesh, a developer must define exactly how vertices, transforms, materials, lights and the camera interact with each other to create that image. This is done using shaders. A <span class="emphasis"><em>shader</em></span> (also known as a <span class="emphasis"><em>programmable shader</em></span>) is a chunk of program code that implements algorithms to get the pixels for a mesh onto the screen. The graphics hardware understands vertices, textures and little else; it has no concept of material, light, transform, or camera. Those high-level structures are interpreted by the shader program. Shaders are typically defined in a high-level C-like language and compiled into code usable by the graphics-processing unit (GPU).</p>
<div class="note" id="all_modern_comp_id1"><p id="all_modern_comp_id2">All modern computers and devices come equipped with a graphics-processing unit, or GPU, a separate processor from the CPU that is dedicated to rendering 3D graphics. The majority of the 3D programming techniques discussed this book assume the presence of a GPU.</p></div>
<p id="shaders_put_ama">Shaders put amazing power at the programmer’s fingertips: full control over every pixel, each time the image is rendered. Shaders power the incredible visuals we see in Hollywood special effects, “CG” animated films, and real-time rendering in today’s video games. With shader support now in web browsers, we can get the same production value as a top video game in our WebGL applications, as well as fine control over how CSS elements are presented and animated on a page.</p>
<p id="shows_a_webgl_w"><a class="xref" href="ch01.html#camera_comma_viewport_and_projection" title="Figure 1-5. Camera, Viewport and Projection Reproduced with permission">Figure 1-5</a> shows a WebGL water simulation rendered using a programmable shader. The rippling water and dancing lights are incredibly realistic, and you can interact with the scene while it is simulating, all in real-time. Reminder: this is running in a web browser!</p>
<div class="figure" id="webgl_water_simulation_using_programmabl">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-6.png" alt="WebGL water simulation using programmable shaders, by Evan Wallace ()"></div></div>
<div class="figure-title">Figure 1-6. WebGL water simulation using programmable shaders, by Evan Wallace (<a class="ulink" href="http://madebyevan.com/webgl-water/" target="_top">http://madebyevan.com/webgl-water/</a>)</div>
</div>
<p id="these_types_of_">These types of effects aren’t limited to WebGL. <a class="xref" href="ch01.html#webgl_water_simulation_using_programmabl" title="Figure 1-6. WebGL water simulation using programmable shaders, by Evan Wallace ()">Figure 1-6</a> shows the before/after of a DOM element using a CSS Custom Filter to create a “crumple” effect. When the mouse is rolled over the element, a shader program distorts the vertices that comprise the display rectangle for the element, animating the vertices over a short time interval until they appear like crumpled paper. What is most significant about animating with CSS Custom Filters is that the contents of the DOM element are standard HTML: a few bits of text with styles, plus an image. CSS Custom Filters allow web developers to leverage their existing knowledge of HTML while creating new eye-catching interactive effects.</p>
<div class="figure" id="crumple_shader_comma_a_css3_custom_filte">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_1-7.png" alt="Crumple Shader, a CSS3 Custom Filter by Altered Qualia ()"></div></div>
<div class="figure-title">Figure 1-7. Crumple Shader, a CSS3 Custom Filter by Altered Qualia (<a class="ulink" href="http://alteredqualia.com/css-shaders/crumple.html" target="_top">http://alteredqualia.com/css-shaders/crumple.html</a>)</div>
</div>
<p id="here_are_a_few_">Here are a few subtle things to note about shaders relative to the technologies we will cover in the book:</p>
<div class="itemizedlist" id="webgl_and_css_c_id1"><ul class="itemizedlist">
<li class="listitem"><p id="webgl_and_css_c_id2">WebGL and CSS custom filters both use shaders defined in the OpenGL ES Shader Language (called <span class="emphasis"><em>GLSL ES</em></span>). There are some differences between the shaders you write for WebGL vs. CSS, but the base languages are identical.</p></li>
<li class="listitem"><p id="webgl_requires_">WebGL <span class="emphasis"><em>requires</em></span> the developer to supply shaders in order for objects to be drawn. If no shader is supplied, or there is an error in compiling or loading the shader, nothing will render on the screen.</p></li>
<li class="listitem"><p id="with_css_filte">With CSS3 Filters, shaders are <span class="emphasis"><em>optional</em></span>. When shaders are used with a CSS3 Filter, it is referred to as a <span class="emphasis"><em>custom filter</em></span>.</p></li>
<li class="listitem"><p id="the_canvas_d_a">The Canvas 2D API <span class="emphasis"><em>does not</em></span> support programmable shaders. If you plan to employ 2D Canvas drawing as a fallback to WebGL rendering, you will need to accommodate for this in your rendering code. More on this in Chapter XX.</p></li>
</ul></div>
<p id="shaders_represe">Shaders represent a bit of a learning curve, with new concepts, another programming language, and great care required. If you find this daunting, don’t worry. There are many popular open source libraries and tools to choose from that hide the gory details of shaders. You may even be able to get through your entire 3D programming career without ever writing a line of GLSL code—though I recommend you try it anyway, just to be able to say you did.</p>
<p id="those_are_the_b">Those are the basics of 3D graphics. Each of the technologies in the book treats the details a little differently, but the concepts translate fairly well across. In the next few chapters we are going to dive deep into the details of creating 3D with WebGL, CSS3 and Canvas 2D. It’s time: everyone—into the pool!</p>
</div>
</div></section><section class="chapter" data-original-filename="ch02.xml" id="webgl_colon_real-time_3d_rendering"><div class="titlepage"><div><div><h1 class="title">Chapter 2. WebGL: Real-time 3D Rendering</h1></div></div></div>
<p id="webgl_is_the_st">WebGL is the standard 3D graphics API for the web. It allows developers to harness the full power of the computer’s 3D rendering hardware from within the browser using JavaScript. Before WebGL, developers had to rely on plugins or native applications and ask their users to download and install custom software in order to deliver a hardware-accelerated 3D experience.</p>
<p id="while_webgl_is_">While WebGL is not in the official HTML5 specification, it is shipped with most browsers that support HTML5. Like Web Workers, Web Sockets and other technologies outside the official W3C recommendations, WebGL comes with the package; the developers at Google, Apple, Mozilla, Opera and Blackberry consider 3D an essential component for making the browser into a first-class application platform.</p>
<p id="webgl_works_on_">WebGL works on the majority of desktops, as well as a growing number of mobile browsers. There are millions of WebGL-enabled seats already installed, most likely including the machines you run at home and in your office. There are numerous sites under development, with applications including games, data visualization, computer-aided design, 3D printing, and consumer retail.</p>
<p id="webgl_is_a_low">WebGL is a low-level drawing API: you supply it with arrays of data and a shader, and tell it to draw. Anyone used to a graphics API like the 2D Canvas will find the lack of high-level constructs mystifying at first. However, there are several open source JavaScript toolkits that provider higher-level access to the API to make it look more like a traditional drawing library. Even with a toolkit, 3D is still hard work— but these tools at least make approachable for folks with limited 3D development experience; and for experienced 3D developers, they are definitely time-savers.</p>
<p id="in_this_chapter">In this chapter we will take a quick tour of the low-level underpinnings of WebGL, to give you a foundation. For the majority of the book we will be using toolkit software that hides most of the API details. But it is important to know what these tools are built upon, so let’s start by exploring WebGL’s core concepts and API.</p>
<div class="sect1" data-original-filename="ch02.xml" id="webgl_n_a_technical_definition">
<div class="titlepage"><div><div><h2 class="title">WebGL – A Technical Definition</h2></div></div></div>
<p id="webgl_is_develo">WebGL is developed and maintained by the Khronos group, the standards body that also governs OpenGL, COLLADA and other specifications you may have heard of. Here is the official description of WebGL, from the Khronos web site:</p>
<div class="blockquote"><blockquote class="blockquote"><p id="webgl_is_a_roya">WebGL is a royalty-free, cross-platform API that brings OpenGL ES 2.0 to the web as a 3D drawing context within HTML, exposed as low-level Document Object Model interfaces. It uses the OpenGL shading language, GLSL ES, and can be cleanly combined with other web content that is layered on top or underneath the 3D content. It is ideally suited for dynamic 3D web applications in the JavaScript programming language, and will be fully integrated in leading web browsers.</p></blockquote></div>
<p id="this_definition">This definition comprises several core ideas. Let’s deconstruct them here.</p>
<div class="itemizedlist" id="webgl_is_an_api_id1"><ul class="itemizedlist">
<li class="listitem"><p id="webgl_is_an_api_id2"><span class="strong"><strong>WebGL is an API</strong></span>. WebGL is accessed exclusively through a set of JavaScript programming interfaces; there are no accompanying tags like there are with HTML. 3D rendering in WebGL is analogous to 2D drawing using the Canvas element, in that it is all done through JavaScript API calls. In fact, access to WebGL is provided using the existing Canvas element and obtaining a special drawing context specific to WebGL.</p></li>
<li class="listitem"><p id="webgl_is_based__id1"><span class="strong"><strong>WebGL is based on OpenGL ES 2.0</strong></span>. OpenGL ES is an adaption of the long-established 3D rendering standard OpenGL. The “ES” stands for “embedded systems,” meaning that it has been tailored for use in small computing devices, most notably phones and tablets. OpenGL ES is the API that powers 3D graphics for iPhone, iPad, Android phones and Android tablets. WebGL’s designers felt that, by basing the API on OpenGL ES’s small footprint, it would be more achievable to deliver a consistent, cross-platform, cross-browser 3D API for the web.</p></li>
<li class="listitem"><p id="webgl_combines_"><span class="strong"><strong>WebGL combines with other web content</strong></span>. WebGL layers on top of or underneath other page content. The 3D canvas can take up just a portion of the page, or the whole page. It can reside inside <code class="literal">&lt;div&gt;</code> tags that are z-ordered. This means that you develop your 3D graphics using WebGL, but all your other elements are built using familiar old HTML. The browser composites (combines) all of the graphics on the page into a seamless experience for the user.</p></li>
<li class="listitem"><p id="webgl_is_built_"><span class="strong"><strong>WebGL is built for dynamic web applications</strong></span>. WebGL has been designed with web delivery in mind. WebGL starts with OpenGL ES, but it has been adapted with specific features that integrate well with web browsers, work with the JavaScript language, and are friendly for web delivery.</p></li>
<li class="listitem"><p id="webgl_is_cross"><span class="strong"><strong>WebGL is cross-platform</strong></span>. WebGL is capable of running on any operating system, on devices ranging from phones and tablets to desktop computers.</p></li>
<li class="listitem"><p id="webgl_is_royalt"><span class="strong"><strong>WebGL is royalty-free</strong></span>. Like all open web specifications, WebGL is free to use. Nobody will be asking you to pay royalties for the privilege.</p></li>
</ul></div>
<p id="the_makers_of_c">The makers of Chrome, Firefox, Safari, Opera and the Blackberry browser have committed significant resources to developing and supporting WebGL, and engineers from these teams are also key members of the working group that develops the specification. The WebGL specification process is open to all Khronos members, and there are also mailing lists open to the public. See appendix X for a list of mailing lists and other specification resources.</p>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="the_webgl_api">
<div class="titlepage"><div><div><h2 class="title">The WebGL API</h2></div></div></div>
<p id="webgl_is_based__id2">WebGL is based on the long-established graphics API known as OpenGL. Originally developed in the late 1980’s, OpenGL has been an industry standard API for a very long time, having endured competitive threats from Microsoft Direct X to emerge as the undisputed standard for programming 3D graphics.</p>
<p id="but_not_all_ope">But not all OpenGL’s are the same. The characteristics of various platforms, including desktop computers, set-top televisions, smart phones and tablets, are so divergent that different editions of OpenGL had to be developed. OpenGL ES (for “embedded systems”) is the version of OpenGL developed to run on small devices such as set-top TV’s and smart phones. Perhaps unforeseen at the time of its development, it turns out the OpenGL ES forms the ideal core for WebGL. It is small and lean, which means that not only is it (relatively) straightforward to implement in a browser, but it makes it much more likely that the developers of the different browsers implement it consistently, and that a WebGL application written for one browser will work identically in another browser.</p>
<p id="the_lean_nature">The lean nature of WebGL puts the onus on application developers to do a lot of work. There is no DOM representation of the 3D scene; there are no natively supported 3D file formats for loading geometry and animations; and with the exception of a few low-level system events, there is no built-in event model to report the goings-on within the 3D canvas—e.g. no mouse-click events telling you what object was clicked on. To the average web developer, WebGL represents a steep learning curve full of truly alien concepts.</p>
<p id="the_good_news_h">The good news here is that there are several open source code libraries out there that make WebGL development approachable. Think of them as existing at the level of JQuery or Prototype.js, though the analogy is rough at best. We will be talking about these libraries in the next few chapters. But right now, we are going to take a quick tour of the underpinnings, the drive train if you will, of WebGL. Even if you never write low-level WebGL for your projects, it’s good to know what’s happening under the hood.</p>
<p id="perhaps_a_quick">Perhaps a quick history of the API, starting with Vlad’s Canvas3D work.</p>
<div class="sect2" id="the_anatomy_of_a_webgl_application">
<div class="titlepage"><div><div><h3 class="title">The Anatomy of a WebGL Application</h3></div></div></div>
<p id="at_the_end_of_t">At the end of the day, WebGL is just a drawing library; another kind of canvas, akin to the 2D Canvas supported in all HTML5 browsers. In fact, WebGL actually uses the HTML5 <code class="literal">&lt;canvas&gt;</code> element to get 3D graphics into the browser page.</p>
<p id="in_order_to_ren_id2">In order to render WebGL into a page, an application must, at a minimum, perform the following steps:</p>
<div class="orderedlist" id="create_a_canvas_id1"><ol class="orderedlist" type="1">
<li class="listitem"><p id="create_a_canvas_id2">Create a canvas element</p></li>
<li class="listitem"><p id="obtain_a_drawin">Obtain a drawing context for the canvas</p></li>
<li class="listitem"><p id="initialize_the__id1">Initialize the viewport</p></li>
<li class="listitem"><p id="create_one_or_m_id1">Create one or more buffers containing the data to be rendered (typically vertices)</p></li>
<li class="listitem"><p id="create_one_or_m_id2">Create one or more matrices to define the transformation from vertex buffers to screen space</p></li>
<li class="listitem"><p id="create_one_or_m_id3">Create one or more shaders to implement the drawing algorithm</p></li>
<li class="listitem"><p id="initialize_the__id2">Initialize the shaders with parameters</p></li>
<li class="listitem"><p id="draw">Draw</p></li>
</ol></div>
<p id="lets_look_at_a">Let’s look at a few examples to illustrate this flow.</p>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="a_simple_webgl_example">
<div class="titlepage"><div><div><h2 class="title">A Simple WebGL Example</h2></div></div></div>
<p id="to_illustrate_t">To illustrate the basic workings of the WebGL API, we are going to write very simple code that draws a single white square on the canvas. See the file <code class="filename">Chapter 2/example2-1.html</code> for a full code listing. The result is shown in <a class="xref" href="ch02.html#a_square_drawn_with_webgl" title="Figure 2-1. A Square Drawn with WebGL">Figure 2-1</a>.</p>
<div class="figure" id="a_square_drawn_with_webgl">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_2-1.png" alt="A Square Drawn with WebGL"></div></div>
<div class="figure-title">Figure 2-1. A Square Drawn with WebGL</div>
</div>
<div class="note" id="the_samples_in__id1"><p id="the_samples_in__id2">The samples in this section are heavily inspired by the lessons at Learning WebGL (<a class="ulink" href="http://www.learningwebgl.com/" target="_top">http://www.learningwebgl.com/</a>), a wonderful site originally developed by Giles Thomas (<a class="ulink" href="http://www.gilesthomas.com/" target="_top">http://www.gilesthomas.com/</a>). Learning WebGL is a fantastic resource for getting to know the WebGL API through tutorials, as well as seeing what cool things are being developed with WebGL around the globe.</p></div>
<div class="sect2" id="the_canvas_element_and_webgl_drawing_con">
<div class="titlepage"><div><div><h3 class="title">The Canvas Element and WebGL Drawing Context</h3></div></div></div>
<p id="all_webgl_rende">All WebGL rendering takes place in a <span class="emphasis"><em>context</em></span>, a browser DOM object that provides the complete WebGL API. This structure mirrors the 2D drawing context provided in the HTML5 Canvas element. To get WebGL into your web page, create a <code class="literal">&lt;canvas&gt;</code> tag somewhere on the page, get the DOM object associated with it (say, using <code class="literal">document.getElementById()</code>), and then get a WebGL context for it. <a class="xref" href="ch02.html#obtaining_a_webgl_context_from_a_canvas" title="Example 2-1. Obtaining a WebGL Context from a Canvas">Example 2-1</a> shows how to get the WebGL context from a canvas DOM element.</p>
<div class="example" id="obtaining_a_webgl_context_from_a_canvas">
<div class="example-title">Example 2-1. Obtaining a WebGL Context from a Canvas</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_initwe">     <code class="kd">function</code> <code class="nx">initWebGL</code><code class="p">(</code><code class="nx">canvas</code><code class="p">)</code> <code class="p">{</code>

        <code class="kd">var</code> <code class="nx">gl</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">msg</code> <code class="o">=</code> <code class="s2">"Your browser does not support WebGL, "</code> <code class="o">+</code>
            <code class="s2">"or it is not enabled by default."</code><code class="p">;</code>
        <code class="k">try</code>
        <code class="p">{</code>
            <code class="nx">gl</code> <code class="o">=</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">getContext</code><code class="p">(</code><code class="s2">"experimental-webgl"</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="nx">msg</code> <code class="o">=</code> <code class="s2">"Error creating WebGL Context!: "</code> <code class="o">+</code> <code class="nx">e</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>
        <code class="p">}</code>

        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">gl</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="nx">alert</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">return</code> <code class="nx">gl</code><code class="p">;</code>
     <code class="p">}</code></pre></div>
</div>
<div class="note" id="note_the_tryca_id1"><p id="note_the_tryca_id2">Note the try/catch block in the example. This is very important, because some browsers still do not support WebGL, or even if they do, the user may not have the most recent version of that browser that includes WebGL support. Further, even browsers that do support WebGL may be running on old hardware, and not be able to give you a valid WebGL rendering context. So, detection code like the above will help you with deploying a fallback such as a rendering based on a 2D canvas— or at the very least, provide you with a graceful exit.</p></div>
</div>
<div class="sect2" id="the_viewport">
<div class="titlepage"><div><div><h3 class="title">The Viewport</h3></div></div></div>
<p id="once_you_have_o">Once you have obtained a valid WebGL drawing context from your canvas, you need to tell it the rectangular bounds of where to draw. In WebGL this is called a <span class="emphasis"><em>viewport</em></span>. Setting the viewport in WebGL is simple; just call the context’s <code class="literal">viewport()</code> method:</p>
<div class="example" id="setting_the_webgl_viewport">
<div class="example-title">Example 2-2. Setting the WebGL Viewport</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_initvi">    <code class="kd">function</code> <code class="nx">initViewport</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">canvas</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">viewport</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">width</code><code class="p">,</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">height</code><code class="p">);</code>
    <code class="p">}</code></pre></div>
</div>
<p id="recall_that_the">Recall that the <code class="literal">gl</code> object used here was created by our helper function <code class="literal">initWebGL()</code>. In this case we have initialized the WebGL viewport to take up the entire contents of the canvas’s display area.</p>
</div>
<div class="sect2" id="buffers_comma_arraybuffer_and_typed_arra">
<div class="titlepage"><div><div><h3 class="title">Buffers, ArrayBuffer and Typed Arrays</h3></div></div></div>
<p id="now_we_have_a_">Now, we have a context ready for drawing. This is pretty much where the similarities to 2D Canvas end.</p>
<p id="webgl_drawing_i">WebGL drawing is done with <span class="emphasis"><em>primitives</em></span>—types of objects to draw such as triangle sets (arrays of triangles), triangle strips (described below), points and lines. Primitives use arrays of data, called buffers, which define the positions of the vertices to be drawn. <a class="xref" href="ch02.html#creating_vertex_buffer_data" title="Example 2-3. Creating Vertex Buffer Data">Example 2-3</a> shows how to create the vertex buffer data for a unit (1×1) square. The results are returned in a JavaScript object containing the vertex buffer data, the size of a vertex structure (in this case, 3 floating point numbers to store x, y and z), the number of vertices to be drawn, and the type of primitive that will be used to draw the square, in this example, a triangle strip. A triangle strip is a rendering primitive that defines a sequence of triangles using the first three vertices for the first triangle, and each subsequent vertex in combination with the previous two for subsequent triangles.</p>
<div class="example" id="creating_vertex_buffer_data">
<div class="example-title">Example 2-3. Creating Vertex Buffer Data</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="create_the_v_id1">    <code class="c1">// Create the vertex data for a square to be drawn</code>
    <code class="kd">function</code> <code class="nx">createSquare</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">vertexBuffer</code><code class="p">;</code>
        <code class="nx">vertexBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">vertexBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">verts</code> <code class="o">=</code> <code class="p">[</code>
             <code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code><code class="p">,</code>
            <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code><code class="p">,</code>
             <code class="p">.</code><code class="mi">5</code><code class="p">,</code> <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code><code class="p">,</code>
            <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code> <code class="o">-</code><code class="p">.</code><code class="mi">5</code><code class="p">,</code>  <code class="mf">0.0</code>
        <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">verts</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">square</code> <code class="o">=</code> <code class="p">{</code><code class="nx">buffer</code><code class="o">:</code><code class="nx">vertexBuffer</code><code class="p">,</code> <code class="nx">vertSize</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code> <code class="nx">nVerts</code><code class="o">:</code><code class="mi">4</code><code class="p">,</code> <code class="nx">primtype</code><code class="o">:</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TRIANGLE_STRIP</code><code class="p">};</code>
        <code class="k">return</code> <code class="nx">square</code><code class="p">;</code>
    <code class="p">}</code></pre></div>
</div>
<p id="note_the_use_of">Note the use of the type <code class="literal">Float32Array</code>. This is a new data type introduced into web browsers for use with WebGL. <code class="literal">Float32Array</code> is a type of <span class="emphasis"><em>ArrayBuffer</em></span>, also known as a <span class="emphasis"><em>Typed Array</em></span>. This is a JavaScript type that stores compact binary data. Typed arrays can be accessed from JavaScript using the same syntax as ordinary arrays, but are much faster and consume less memory. They are ideal for use with binary data where performance is critical. Typed arrays can be put to general use, but their introduction into web browsers was pioneered by the WebGL effort. The latest typed array specification can be found on the Khronos web site at <a class="ulink" href="http://www.khronos.org/registry/typedarray/specs/latest/" target="_top">http://www.khronos.org/registry/typedarray/specs/latest/</a>.</p>
</div>
<div class="sect2" id="matrices">
<div class="titlepage"><div><div><h3 class="title">Matrices</h3></div></div></div>
<p id="before_we_can_d">Before we can draw the square, we must create a couple of matrices. First, we need a matrix to define where the square is positioned in our 3D coordinate system, relative to the camera. This is known as a <span class="emphasis"><em>ModelView matrix</em></span>, because it combines transformations of the model (3D mesh) and the camera. In our example, we are transforming the square by translating it along the negative z-axis, i.e. moving it away from the camera by −3.333 units. The second matrix we need is the <span class="emphasis"><em>projection matrix</em></span>, which will be required by our shader to convert the 3D space coordinates of the model in camera space into 2D coordinates drawn in the space of the viewport. In this example, the projection matrix defines a 45-degree field of view perspective camera.</p>
<p id="in_webgl_matri">In WebGL, matrices are represented simply as typed arrays of numbers; for example, a 4×4 matrix has a <code class="literal">Float32Array</code> of 16 elements. To help us with setting up and manipulating our matrices, we are using a great open source library called <span class="emphasis"><em>glMatrix</em></span> (<a class="ulink" href="https://github.com/toji/gl-matrix" target="_top">https://github.com/toji/gl-matrix</a>), written Brandon Jones, now an engineer at Google. The matrix setup code is shown in <a class="xref" href="ch02.html#setting_up_the_projection_and_modelview" title="Example 2-4. Setting Up the Projection and ModelView Matrices">Example 2-4</a>.</p>
<div class="example" id="setting_up_the_projection_and_modelview">
<div class="example-title">Example 2-4. Setting Up the Projection and ModelView Matrices</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_projectionm">    <code class="kd">var</code> <code class="nx">projectionMatrix</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">initMatrices</code><code class="p">(</code><code class="nx">canvas</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="c1">// Create a model view matrix with camera at 0, 0, −3.333</code>
        <code class="nx">modelViewMatrix</code> <code class="o">=</code> <code class="nx">mat4</code><code class="p">.</code><code class="nx">create</code><code class="p">();</code>
        <code class="nx">mat4</code><code class="p">.</code><code class="nx">translate</code><code class="p">(</code><code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="err">−</code><code class="mf">3.333</code><code class="p">]);</code>

        <code class="c1">// Create a project matrix with 45 degree field of view</code>
        <code class="nx">projectionMatrix</code> <code class="o">=</code> <code class="nx">mat4</code><code class="p">.</code><code class="nx">create</code><code class="p">();</code>
        <code class="nx">mat4</code><code class="p">.</code><code class="nx">perspective</code><code class="p">(</code><code class="nx">projectionMatrix</code><code class="p">,</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">/</code> <code class="mi">4</code><code class="p">,</code>
            <code class="nx">canvas</code><code class="p">.</code><code class="nx">width</code> <code class="o">/</code> <code class="nx">canvas</code><code class="p">.</code><code class="nx">height</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">10000</code><code class="p">);</code>
    <code class="p">}</code></pre></div>
</div>
</div>
<div class="sect2" id="the_shader">
<div class="titlepage"><div><div><h3 class="title">The Shader</h3></div></div></div>
<p id="we_are_almost_r">We are almost ready to draw our scene. There is one more important piece of setup: the shader. As described earlier, shaders are small programs written in GLSL, a high-level C-like language, which define how the pixels for 3D objects actually get drawn on the screen. WebGL requires the developer to supply a shader for each object that gets drawn. The shader can be used for multiple objects, so in practice it is often sufficient to supply one shader for the whole application, reusing it with different geometry and parameter values each time.</p>
<p id="a_shader_is_typ">A shader is typically composed of two parts: the <span class="emphasis"><em>vertex shader</em></span> and the <span class="emphasis"><em>fragment shader</em></span> (also known as the <span class="emphasis"><em>pixel shader</em></span>). The vertex shader is responsible for transforming the coordinates of the object into 2D display space; the fragment shader is responsible for generating the final color output of each pixel for the transformed vertices, based on inputs such as color, texture, lighting and material values. In our simple example, the vertex shader combines the <code class="literal">vertexPos</code>, <code class="literal">modelViewMatrix</code> and <code class="literal">projectionMatrix</code> values to create the final, transformed vertex for each input, and the fragment shader simply outputs a hard-coded white color.</p>
<p id="in_webgl_shade">In WebGL, shader setup requires a sequence of steps, including compiling the individual pieces from GLSL source code, then linking them together. <a class="xref" href="ch02.html#the_shader_code" title="Example 2-5. The Shader Code">Example 2-5</a> lists the shader code. Let’s walk through it. First, we define a helper function, <code class="literal">createShader()</code> that uses WebGL methods to compile the vertex and fragment shaders from source code. The GLSL source code is supplied as JavaScript strings that we define as global variables <code class="literal">vertexShaderSource</code> and <code class="literal">fragmentShaderSource</code>.</p>
<div class="note" id="in_the_examples_id1"><p id="in_the_examples_id2">In the examples in this chapter, GLSL source code is supplied as JavaScript strings stored in variables. This is a bit ugly, as we have to concatenate strings separated by newlines to construct our source. As an alternative, we could have defined the shader in external text files and loaded them via Ajax; or we could have created hidden DOM elements and tucked the source into their <code class="literal">textContent</code>. We did it this way for this example so that we could keep things simple for now.</p></div>
<p id="once_the_parts_">Once the parts of the shader have been compiled, they need to be linked together into a working program using the WebGL methods <code class="literal">gl.createProgram()</code>, <code class="literal">gl.attachShader()</code> and <code class="literal">gl.linkProgram()</code>. Once linking is successful, we have to do one more thing before we are ready to use the shader program: obtain a handle to each of the variables defined in the GLSL shader code so that they can be initialized with values from the JavaScript code. This is done using the WebGL methods <code class="literal">gl.getAttribLocation()</code> and <code class="literal">gl.getUniformLocation()</code>.</p>
<div class="example" id="the_shader_code">
<div class="example-title">Example 2-5. The Shader Code</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_create">        <code class="kd">function</code> <code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">str</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">shader</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">type</code> <code class="o">==</code> <code class="s2">"fragment"</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">shader</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">FRAGMENT_SHADER</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">type</code> <code class="o">==</code> <code class="s2">"vertex"</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">shader</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">VERTEX_SHADER</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="nx">gl</code><code class="p">.</code><code class="nx">shaderSource</code><code class="p">(</code><code class="nx">shader</code><code class="p">,</code> <code class="nx">str</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">compileShader</code><code class="p">(</code><code class="nx">shader</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">gl</code><code class="p">.</code><code class="nx">getShaderParameter</code><code class="p">(</code><code class="nx">shader</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">COMPILE_STATUS</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">alert</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">getShaderInfoLog</code><code class="p">(</code><code class="nx">shader</code><code class="p">));</code>
            <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="k">return</code> <code class="nx">shader</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">var</code> <code class="nx">vertexShaderSource</code> <code class="o">=</code>

        <code class="s2">"    attribute vec3 vertexPos;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 modelViewMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 projectionMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"        // Return the transformed and projected vertex value\n"</code> <code class="o">+</code>
        <code class="s2">"        gl_Position = projectionMatrix * modelViewMatrix * \n"</code> <code class="o">+</code>
        <code class="s2">"            vec4(vertexPos, 1.0);\n"</code> <code class="o">+</code>
        <code class="s2">"    }\n"</code><code class="p">;</code>

    <code class="kd">var</code> <code class="nx">fragmentShaderSource</code> <code class="o">=</code>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"    // Return the pixel color: always output white\n"</code> <code class="o">+</code>
        <code class="s2">"    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n"</code> <code class="o">+</code>
        <code class="s2">"}\n"</code><code class="p">;</code>


    <code class="kd">var</code> <code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">shaderVertexPositionAttribute</code><code class="p">,</code> <code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="nx">shaderModelViewMatrixUniform</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">initShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// load and compile the fragment and vertex shader</code>
        <code class="c1">//var fragmentShader = getShader(gl, "fragmentShader");</code>
        <code class="c1">//var vertexShader = getShader(gl, "vertexShader");</code>
        <code class="kd">var</code> <code class="nx">fragmentShader</code> <code class="o">=</code> <code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">fragmentShaderSource</code><code class="p">,</code> <code class="s2">"fragment"</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">vertexShader</code> <code class="o">=</code> <code class="nx">createShader</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">vertexShaderSource</code><code class="p">,</code> <code class="s2">"vertex"</code><code class="p">);</code>

        <code class="c1">// link them together into a new program</code>
        <code class="nx">shaderProgram</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createProgram</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">attachShader</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">vertexShader</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">attachShader</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">fragmentShader</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">linkProgram</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">);</code>

        <code class="c1">// get pointers to the shader params</code>
        <code class="nx">shaderVertexPositionAttribute</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">getAttribLocation</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="s2">"vertexPos"</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">enableVertexAttribArray</code><code class="p">(</code><code class="nx">shaderVertexPositionAttribute</code><code class="p">);</code>

        <code class="nx">shaderProjectionMatrixUniform</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">getUniformLocation</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="s2">"projectionMatrix"</code><code class="p">);</code>
        <code class="nx">shaderModelViewMatrixUniform</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">getUniformLocation</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="s2">"modelViewMatrix"</code><code class="p">);</code>


        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">gl</code><code class="p">.</code><code class="nx">getProgramParameter</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">LINK_STATUS</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">alert</code><code class="p">(</code><code class="s2">"Could not initialise shaders"</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code></pre></div>
</div>
</div>
<div class="sect2" id="drawing_primitives">
<div class="titlepage"><div><div><h3 class="title">Drawing Primitives</h3></div></div></div>
<p id="now_we_are_rea">Now, we are ready to draw our square. Our context has been created; our viewport has been set; our vertex buffer, matrices and shader have been created and initialized. We define a function, <code class="literal">draw()</code>, which takes the WebGL context and our previously created square object. First, the function clears the canvas with a black background color. Then, it sets (“binds”) the vertex buffer for the square to be drawn, sets (“uses”) the shader to use, and connects up the vertex buffer and matrices to the shader as inputs. Finally, we call the WebGL <code class="literal">drawArrays()</code> method to draw the square. We simply tell it which type of primitive and how many vertices in the primitive; WebGL knows everything else already because we have previously set those other items (vertices, matrices, shaders) as state in the context.</p>
<div class="example" id="the_drawing_code">
<div class="example-title">Example 2-6. The Drawing Code</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_drawg_id1">     <code class="kd">function</code> <code class="nx">draw</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>

         <code class="c1">// clear the background (with black)</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">clearColor</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">);</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">clear</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">COLOR_BUFFER_BIT</code><code class="p">);</code>

         <code class="c1">// set the vertex buffer to be drawn</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">buffer</code><code class="p">);</code>

         <code class="c1">// set the shader to use</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">useProgram</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">);</code>

         <code class="c1">// connect up the shader parameters: vertex position and projection/model matrices</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderVertexPositionAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">vertSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">projectionMatrix</code><code class="p">);</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderModelViewMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">);</code>

         <code class="c1">// draw the object</code>
         <code class="nx">gl</code><code class="p">.</code><code class="nx">drawArrays</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">primtype</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">nVerts</code><code class="p">);</code>
      <code class="p">}</code></pre></div>
</div>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="creating_3d_geometry">
<div class="titlepage"><div><div><h2 class="title">Creating 3D Geometry</h2></div></div></div>
<p id="the_square_was_">The square was about as simple a WebGL example as we can contrive. Obviously, it’s not very interesting—it’s not even 3D—yet it clocks in at nearly 200 lines of code. The corresponding 2D Canvas drawing code would be around 30 lines at most. At this point it’s clearly not a win over using other drawing APIs. But here is where it gets interesting. Now we are going to use WebGL to do true 3D drawing. We’ll need a few extra lines of code to create the geometry for a 3D cube with multiple colors, and we will have to make a few small changes to the shader and the drawing function. We are also going to throw in a simple animation so that we can see the cube from all sides. <a class="xref" href="ch02.html#a_multi-colored_cube" title="Figure 2-2. A Multi-Colored Cube">Figure 2-2</a> shows a screen shot of the cube in mid-rotation.</p>
<div class="figure" id="a_multi-colored_cube">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_2-2.png" alt="A Multi-Colored Cube"></div></div>
<div class="figure-title">Figure 2-2. A Multi-Colored Cube</div>
</div>
<p id="to_create_and_r">To create and render the cube, we need to adapt the previous example in a few places. First, we must change the code that creates the buffers to create cube geometry instead of square geometry. We also need to change the drawing code to use a different WebGL drawing method. File <code class="filename">Chapter 2/example2-2.html</code> contains the code.</p>
<p id="shows_the_buffe"><a class="xref" href="ch02.html#code_to_set_up_cube_geometry_comma_color" title="Example 2-7. Code to Set Up Cube Geometry, Color and Index Buffers">Example 2-7</a> shows the buffer setup for our cube. It is a bit more involved than the code to draw a square, not only because there are more vertices, but because we also want to supply different colors for each face of the cube. We first create the vertex buffer data and store it our variable <code class="literal">vertexBuffer</code>. Then, we create color data, one four-element color per vertex, and store it in <code class="literal">colorBuffer</code>. Finally, we create a new kind of buffer, called an <span class="emphasis"><em>index buffer</em></span>, to hold a set of indices into the vertex buffer data. We store this in the variable <code class="literal">cubeIndexBuffer</code>. This is done because the drawing primitive we will use in our updated <code class="literal">draw()</code> function requires indices into the set of vertices, instead of the vertices themselves, in order to define the triangles. Why do this? Because 3D geometry often represents contiguous, closed regions where vertex positions are shared among multiple triangles; indexed buffers allow the data to be stored more compactly by avoiding repetition of data.</p>
<div class="example" id="code_to_set_up_cube_geometry_comma_color">
<div class="example-title">Example 2-7. Code to Set Up Cube Geometry, Color and Index Buffers</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="create_the_v_id2">    <code class="c1">// Create the vertex, color and index data for a multi-colored cube</code>
    <code class="kd">function</code> <code class="nx">createCube</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// Vertex Data</code>
        <code class="kd">var</code> <code class="nx">vertexBuffer</code><code class="p">;</code>
        <code class="nx">vertexBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">vertexBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">verts</code> <code class="o">=</code> <code class="p">[</code>
           <code class="c1">// Front face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Back face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Top face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Bottom face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Right face</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
            <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>

           <code class="c1">// Left face</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code>
           <code class="err">−</code><code class="mf">1.0</code><code class="p">,</code>  <code class="mf">1.0</code><code class="p">,</code> <code class="err">−</code><code class="mf">1.0</code>
           <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">verts</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>

        <code class="c1">// Color data</code>
        <code class="kd">var</code> <code class="nx">colorBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">colorBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">faceColors</code> <code class="o">=</code> <code class="p">[</code>
            <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Front face</code>
            <code class="p">[</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Back face</code>
            <code class="p">[</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Top face</code>
            <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Bottom face</code>
            <code class="p">[</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code> <code class="c1">// Right face</code>
            <code class="p">[</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">]</code>  <code class="c1">// Left face</code>
        <code class="p">];</code>
        <code class="kd">var</code> <code class="nx">vertexColors</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="k">in</code> <code class="nx">faceColors</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">color</code> <code class="o">=</code> <code class="nx">faceColors</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
            <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">j</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="mi">4</code><code class="p">;</code> <code class="nx">j</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">vertexColors</code> <code class="o">=</code> <code class="nx">vertexColors</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">color</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">vertexColors</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>

        <code class="c1">// Index data (defines the triangles to be drawn)</code>
        <code class="kd">var</code> <code class="nx">cubeIndexBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">cubeIndexBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">cubeIndices</code> <code class="o">=</code> <code class="p">[</code>
            <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code>      <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code>    <code class="c1">// Front face</code>
            <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code>      <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code>    <code class="c1">// Back face</code>
            <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code>     <code class="mi">8</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code>  <code class="c1">// Top face</code>
            <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code>   <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="c1">// Bottom face</code>
            <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code>   <code class="mi">16</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code> <code class="c1">// Right face</code>
            <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code>   <code class="mi">20</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code>  <code class="c1">// Left face</code>
        <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Uint16Array</code><code class="p">(</code><code class="nx">cubeIndices</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code>

        <code class="kd">var</code> <code class="nx">cube</code> <code class="o">=</code> <code class="p">{</code><code class="nx">buffer</code><code class="o">:</code><code class="nx">vertexBuffer</code><code class="p">,</code> <code class="nx">colorBuffer</code><code class="o">:</code><code class="nx">colorBuffer</code><code class="p">,</code> <code class="nx">indices</code><code class="o">:</code><code class="nx">cubeIndexBuffer</code><code class="p">,</code>
                <code class="nx">vertSize</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code> <code class="nx">nVerts</code><code class="o">:</code><code class="mi">24</code><code class="p">,</code> <code class="nx">colorSize</code><code class="o">:</code><code class="mi">4</code><code class="p">,</code> <code class="nx">nColors</code><code class="o">:</code> <code class="mi">24</code><code class="p">,</code> <code class="nx">nIndices</code><code class="o">:</code><code class="mi">36</code><code class="p">,</code>
                <code class="nx">primtype</code><code class="o">:</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TRIANGLES</code><code class="p">};</code>

        <code class="k">return</code> <code class="nx">cube</code><code class="p">;</code>
    <code class="p">}</code></pre></div>
</div>
<p id="in_order_for_th">In order for the cube colors to be drawn, they must be passed to the shader. <a class="xref" href="ch02.html#shader_code_to_render_the_cube_with_colo" title="Example 2-8. Shader Code to Render the Cube with Colors">Example 2-8</a> shows the updated shader code. Note the lines in boldface: we declare a new vertex attribute to represent the color. We also need to declare a GLSL <code class="literal">varying</code> variable, <code class="literal">vColor</code>, which is used to pass per-vertex color information from the vertex shader to the fragment shader. Unlike <code class="literal">uniform</code> types such as the matrices discussed earlier, which do not change values from vertex to vertex, <code class="literal">varying</code> types represent information for which the shader can output a different value for each vertex. In this case, we are going to pull the color input from the color buffer data stored in memory in the <code class="literal">vertexColor</code> attribute. The fragment shader uses <code class="literal">vColor</code> unchanged to output the final pixel color value.</p>
<div class="example" id="shader_code_to_render_the_cube_with_colo">
<div class="example-title">Example 2-8. Shader Code to Render the Cube with Colors</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_vertexshade_id1">     <code class="kd">var</code> <code class="nx">vertexShaderSource</code> <code class="o">=</code>

        <code class="s2">"    attribute vec3 vertexPos;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    attribute vec4 vertexColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    uniform mat4 modelViewMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 projectionMatrix;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    varying vec4 vColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"        // Return the transformed and projected vertex value\n"</code> <code class="o">+</code>
        <code class="s2">"        gl_Position = projectionMatrix * modelViewMatrix * \n"</code> <code class="o">+</code>
        <code class="s2">"            vec4(vertexPos, 1.0);\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"        // Output the vertexColor in vColor\n"</code> <code class="o">+</code></strong></span>
        <span class="strong"><strong><code class="s2">"        vColor = vertexColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    }\n"</code><code class="p">;</code>

    <code class="kd">var</code> <code class="nx">fragmentShaderSource</code> <code class="o">=</code>
        <span class="strong"><strong><code class="s2">"    precision mediump float;\n"</code> <code class="o">+</code></strong></span>
        <span class="strong"><strong><code class="s2">"    varying vec4 vColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"    // Return the pixel color: always output white\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    gl_FragColor = vColor;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"}\n"</code><code class="p">;</code></pre></div>
</div>
<div class="note" id="this_code_may_s_id1"><p id="this_code_may_s_id2">This code may seem a bit complicated just to set a single color value. But a less trivial shader—such as one that implements a lighting model, or a shader that animates a procedural texture for grass, water or other effects—would perform many additional calculations on <code class="literal">vColor</code> before outputting the final color. No doubt that shaders provide a lot of visual power; but with that great power comes, as Ben Parker famously observed, great responsibility.</p></div>
<p id="now_for_the_dra">Now for the drawing code, shown in <a class="xref" href="ch02.html#revised_cube-drawing_code" title="Example 2-9. Revised Cube-Drawing Code">Example 2-9</a>. We have to do a few things differently for the more complex cube geometry. The lines in boldface show the changes. First, we make sure WebGL knows we are drawing depth-sorted 3D objects, by enabling depth testing. Next, we have to bind the color and index buffers created previously in the <code class="literal">createCube()</code> function. Finally, we use the WebGL method <code class="literal">gl.drawElements()</code> instead of <code class="literal">gl.drawArray()</code>. <code class="literal">gl.drawElements()</code> draws a set of primitives using indexed buffer information.</p>
<div class="example" id="revised_cube-drawing_code">
<div class="example-title">Example 2-9. Revised Cube-Drawing Code</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="function_drawg_id2">    <code class="kd">function</code> <code class="nx">draw</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// clear the background (with black)</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">clearColor</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">);</code>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">enable</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">DEPTH_TEST</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">clear</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">COLOR_BUFFER_BIT</code>  <code class="o">|</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">DEPTH_BUFFER_BIT</code><code class="p">);</code></strong></span>

        <code class="c1">// set the shader to use</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">useProgram</code><code class="p">(</code><code class="nx">shaderProgram</code><code class="p">);</code>

         <code class="c1">// connect up the shader parameters: vertex position, color and projection/model matrices</code>
           <code class="c1">// set up the buffers</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">buffer</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderVertexPositionAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">vertSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">colorBuffer</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderVertexColorAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">colorSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">indices</code><code class="p">);</code></strong></span>

        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">projectionMatrix</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderModelViewMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">);</code>

        <span class="strong"><strong><code class="c1">// draw the object</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">drawElements</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">primtype</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">nIndices</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">UNSIGNED_SHORT</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span>
    <code class="p">}</code></pre></div>
</div>
<div class="sect2" id="adding_animation">
<div class="titlepage"><div><div><h3 class="title">Adding Animation</h3></div></div></div>
<p id="if_we_want_to_s">If we want to see the cube as a 3D object instead of a static 2D drawing, we need to animate it. For now we will use a very simple animation technique to tumble the cube around one axis. The animation code is shown in <a class="xref" href="ch02.html#animating_the_cube" title="Example 2-10. Animating the Cube">Example 2-10</a>. Function <code class="literal">animate()</code> rotates the cube around the previously defined <code class="literal">rotationAxis</code> over a period of 5 seconds.</p>
<p id="animate_is_ca"><code class="literal">animate()</code> is called repeatedly by another function, <code class="literal">run()</code>, which drives continuous animation of the 3D scene using a new browser function called <code class="literal">requestAnimationFrame()</code>. This function asks the browser to call a callback function when it is time to redraw the contents of the page. (We will explore <code class="literal">requestAnimationFrame()</code> and various animation techniques in detail in later chapters.) Each time <code class="literal">animate()</code> is called, it stores the difference between the current time and the previous time it was called into variable <code class="literal">deltat</code>, and uses that to derive an angle for rotating <code class="literal">modelViewMatrix</code>. The result is a full rotation around <code class="literal">rotationAxis</code> every 5 seconds.</p>
<div class="example" id="animating_the_cube">
<div class="example-title">Example 2-10. Animating the Cube</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_duration__">    <code class="kd">var</code> <code class="nx">duration</code> <code class="o">=</code> <code class="mi">5000</code><code class="p">;</code> <code class="c1">// ms</code>
    <code class="kd">var</code> <code class="nx">currentTime</code> <code class="o">=</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>
    <code class="kd">function</code> <code class="nx">animate</code><code class="p">()</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">now</code> <code class="o">=</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>
        <code class="kd">var</code> <code class="nx">deltat</code> <code class="o">=</code> <code class="nx">now</code> <code class="o">-</code> <code class="nx">currentTime</code><code class="p">;</code>
        <code class="nx">currentTime</code> <code class="o">=</code> <code class="nx">now</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">fract</code> <code class="o">=</code> <code class="nx">deltat</code> <code class="o">/</code> <code class="nx">duration</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">angle</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">fract</code><code class="p">;</code>
        <code class="nx">mat4</code><code class="p">.</code><code class="nx">rotate</code><code class="p">(</code><code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">,</code> <code class="nx">angle</code><code class="p">,</code> <code class="nx">rotationAxis</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="kd">function</code> <code class="nx">run</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">cube</code><code class="p">)</code> <code class="p">{</code>

        <code class="nx">requestAnimationFrame</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="nx">run</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">cube</code><code class="p">);</code> <code class="p">});</code>
        <code class="nx">draw</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">cube</code><code class="p">);</code>
        <code class="nx">animate</code><code class="p">();</code>
    <code class="p">}</code></pre></div>
</div>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="using_texture_maps">
<div class="titlepage"><div><div><h2 class="title">Using Texture Maps</h2></div></div></div>
<p id="the_final_webgl">The final WebGL API feature to explore in this chapter is texture mapping. <span class="emphasis"><em>Texture maps</em></span>, or simply <span class="emphasis"><em>textures</em></span>, are bitmap images displayed across the surface of geometry. Image data for textures is created using the <code class="literal">Image</code> DOM element, which means that standard web image formats such JPEG and PNG can be supplied to WebGL as textures by simply setting the <code class="literal">Image</code> element’s <code class="literal">src</code> property.</p>
<div class="note" id="webgl_textures__id1"><p id="webgl_textures__id2">WebGL textures don’t need to be created from image files. They can also be created using 2D <code class="literal">Canvas</code> elements, allowing us to draw on the surface of an object using the 2D Canvas drawing API; they can even be created from <code class="literal">Video</code> elements, enabling video playback on the surface of an object. These dynamic texturing capabilities will be explored in a later chapter.</p></div>
<p id="we_have_adapted">We have adapted the previous rotating cube example to use a texture map instead of face colors. The texture-mapped cube is depicted in <a class="xref" href="ch02.html#a_texture-mapped_cube" title="Figure 2-3. A Texture-Mapped Cube">Figure 2-3</a>.</p>
<div class="figure" id="a_texture-mapped_cube">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1234000000802/figs/p3da_Figure_2-3.png" alt="A Texture-Mapped Cube"></div></div>
<div class="figure-title">Figure 2-3. A Texture-Mapped Cube</div>
</div>
<div class="note" id="one_thing_about_id1">
<p id="one_thing_about_id2">One thing about this sample – in case you have been running it by opening the HTML file from your operating system’s file explorer. This one needs to be loaded from a web server, because we are loading a texture map from a JPEG file, which, because of cross-origin security restrictions in WebGL’s security model, requires web server operation rather than access via <code class="literal">file://</code> URLs. In general, most of the examples in this book must be loaded from a web server.</p>
<p id="i_run_a_local_v">I run a local version of a standard LAMP stack on my MacBook... but all you really need is the ‘A’ part of LAMP, i.e. a web server such as Apache. Or if you have Python installed, another option is the SimpleHTTPServer module, which you can run by going to the root of the examples directory and typing</p>
<p id="python_m_simpl"><code class="literal">python -m SimpleHTTPServer</code></p>
<p id="and_then_pointi">and then pointing your web browser at <a class="ulink" href="http://localhost:8000/" target="_top">http://localhost:8000/</a>. There is great tech tip on this feature at the Linux Journal web site at</p>
<p id="para_id3"><a class="ulink" href="http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python" target="_top">http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python</a>.</p>
</div>
<p id="the_full_code_f">The full code for this example is in file <code class="filename">Chapter 2/example2-3.html.</code> <a class="xref" href="ch02.html#creating_a_texture_map_from_an_image" title="Example 2-11. Creating a Texture Map from an Image">Example 2-11</a> shows the code for loading the texture. First, we call <code class="literal">gl.createTexture()</code> to create a new WebGL texture object. Then we set the <code class="literal">image</code> property of the texture to a newly created <code class="literal">Image</code> object. Finally, we set the <code class="literal">src</code> property of the image to load a JPEG file, in this case a 256-pixel square version of the official WebGL logo; but before doing that we register an event handler for image’s <code class="literal">onload</code> event. We do that because we have to do a few more things with the WebGL texture object once the image is loaded.</p>
<p id="in_handletextur">In <code class="literal">handleTextureLoaded()</code>, we do several things. [EXPLAIN BIND TEXTURE]The first one is pretty interesting: we call <code class="literal">gl.pixelStorei()</code> to flip the Y values of all of the pixels in the texture, because in WebGL, texture coordinates increase as Y goes up the screen, whereas web image formats natively store pixel Y values going downward. [EXPLAIN THE OTHER PARAMS]. Finally, we set our <code class="literal">okToRun</code> global to true, which will tell the <code class="literal">run()</code> function that we now have a valid texture and therefore it is ok to call the drawing code.</p>
<div class="example" id="creating_a_texture_map_from_an_image">
<div class="example-title">Example 2-11. Creating a Texture Map from an Image</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_oktorun__f">   <code class="kd">var</code> <code class="nx">okToRun</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">handleTextureLoaded</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">texture</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">texture</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">pixelStorei</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">UNPACK_FLIP_Y_WEBGL</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">texImage2D</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">RGBA</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">RGBA</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">UNSIGNED_BYTE</code><code class="p">,</code> <code class="nx">texture</code><code class="p">.</code><code class="nx">image</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">texParameteri</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_MAG_FILTER</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">NEAREST</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">texParameteri</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_MIN_FILTER</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">NEAREST</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
        <code class="nx">okToRun</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">var</code> <code class="nx">webGLTexture</code><code class="p">;</code>

    <code class="kd">function</code> <code class="nx">initTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">)</code> <code class="p">{</code>
     <code class="nx">webGLTexture</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createTexture</code><code class="p">();</code>
     <code class="nx">webGLTexture</code><code class="p">.</code><code class="nx">image</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Image</code><code class="p">();</code>
     <code class="nx">webGLTexture</code><code class="p">.</code><code class="nx">image</code><code class="p">.</code><code class="nx">onload</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
            <code class="nx">handleTextureLoaded</code><code class="p">(</code><code class="nx">gl</code><code class="p">,</code> <code class="nx">webGLTexture</code><code class="p">)</code>
        <code class="p">}</code>

     <code class="nx">webGLTexture</code><code class="p">.</code><code class="nx">image</code><code class="p">.</code><code class="nx">src</code> <code class="o">=</code> <code class="s2">"../images/webgl-logo-256.jpg"</code><code class="p">;</code>
    <code class="p">}</code></pre></div>
</div>
<p id="as_usual_we_al">As usual, we also have to adapt a few other sections of the code: the buffer creation, the shader, and the part of the drawing code that populates the shader values. First, we replace the code that created a buffer of color information with code that creates a buffer of <span class="emphasis"><em>texture coordinates</em></span>. Textures coordinates are floating-point pairs defined at each vertex, with values typical ranging from 0 to 1. These values represent x, y offsets into the bitmap image data; the shader will use these values to get pixel information from the bitmap as we shall see in the shader code momentarily. Texture coordinate values for our cube are pretty easy: each face uses the entire texture, so the values for any corner of the cube face are at a corner of the texture, e.g. [0, 0], [0, 1], [1, 0] or [1, 1]. <a class="xref" href="ch02.html#buffer_creation_code_for_texture-mapped" title="Example 2-12. Buffer Creation Code for Texture-Mapped Cube">Example 2-12</a> shows the code to create the texture coordinate buffer.</p>
<div class="example" id="buffer_creation_code_for_texture-mapped">
<div class="example-title">Example 2-12. Buffer Creation Code for Texture-Mapped Cube</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_texcoordbuf">       <code class="kd">var</code> <code class="nx">texCoordBuffer</code> <code class="o">=</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">createBuffer</code><code class="p">();</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">texCoordBuffer</code><code class="p">);</code>
        <code class="kd">var</code> <code class="nx">textureCoords</code> <code class="o">=</code> <code class="p">[</code>
          <code class="c1">// Front face</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>

          <code class="c1">// Back face</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>

          <code class="c1">// Top face</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>

          <code class="c1">// Bottom face</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>

          <code class="c1">// Right face</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>

          <code class="c1">// Left face</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">0.0</code><code class="p">,</code>
          <code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
          <code class="mf">0.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code>
        <code class="p">];</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">bufferData</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ARRAY_BUFFER</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">textureCoords</code><code class="p">),</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">STATIC_DRAW</code><code class="p">);</code></pre></div>
</div>
<p id="id_d1e5799">The shader code must be modified to use texture information instead of colors. The vertex shader defines a <code class="literal">texCoord</code> vertex attribute that is passed with the vertex data, and a varying output, <code class="literal">vTexCoord</code>, which will be sent to the fragment shader for each vertex. The fragment shader then uses this texture coordinate as an index into the texture map data, which is passed as a uniform to the fragment shader in the variable <code class="literal">uSampler</code>. The pixel data is retrieved from the texture using a GLSL function called <code class="literal">texture2D()</code>, which takes sampler and a 2D vector x, y position. The updated shader code is shown in <a class="xref" href="ch02.html#shader_code_for_texture-mapped_cube" title="Example 2-13. Shader Code for Texture-Mapped Cube">Example 2-13</a>.</p>
<div class="example" id="shader_code_for_texture-mapped_cube">
<div class="example-title">Example 2-13. Shader Code for Texture-Mapped Cube</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="var_vertexshade_id2">    <code class="kd">var</code> <code class="nx">vertexShaderSource</code> <code class="o">=</code>

        <code class="s2">"    attribute vec3 vertexPos;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    attribute vec2 texCoord;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    uniform mat4 modelViewMatrix;\n"</code> <code class="o">+</code>
        <code class="s2">"    uniform mat4 projectionMatrix;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    varying vec2 vTexCoord;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"        // Return the transformed and projected vertex value\n"</code> <code class="o">+</code>
        <code class="s2">"        gl_Position = projectionMatrix * modelViewMatrix * \n"</code> <code class="o">+</code>
        <code class="s2">"            vec4(vertexPos, 1.0);\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"        // Output the texture coordinate in vTexCoord\n"</code> <code class="o">+</code></strong></span>
        <code class="err">"</code>        <span class="strong"><strong><code class="nx">vTexCoord</code> <code class="o">=</code> <code class="nx">texCoord</code><code class="p">;</code><code class="err">\</code><code class="nx">n</code><code class="err">"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    }\n"</code><code class="p">;</code>

    <code class="kd">var</code> <code class="nx">fragmentShaderSource</code> <code class="o">=</code>
        <code class="s2">"    precision mediump float;\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    varying vec2 vTexCoord;\n"</code> <code class="o">+</code></strong></span>
        <span class="strong"><strong><code class="s2">"    uniform sampler2D uSampler;\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"    void main(void) {\n"</code> <code class="o">+</code>
        <code class="s2">"    // Return the pixel color: always output white\n"</code> <code class="o">+</code>
        <span class="strong"><strong><code class="s2">"    gl_FragColor = texture2D(uSampler, vec2(vTexCoord.s, vTexCoord.t));\n"</code> <code class="o">+</code></strong></span>
        <code class="s2">"}\n"</code><code class="p">;</code></pre></div>
</div>
<p id="as_our_final_st">As our final step in getting textures onto our cube, we have to modify the drawing function a little. <a class="xref" href="ch02.html#example_caption_text_goes_here" title="Example 2-14. Example Caption Text Goes Here">Example 2-14</a> shows the modified code. We replace the color buffer setup code with code that sets up the texture coordinate buffer. We also set the texture to be used and connect it to the shader inputs. (As with shaders and other state in the WebGL API, there is a notion of the current, or “active” texture.) At long last, our cube is ready to draw with <code class="literal">gl.drawElements()</code>.</p>
<div class="example" id="example_caption_text_goes_here">
<div class="example-title">Example 2-14. Example Caption Text Goes Here</div>
<div class="example-contents"><pre class="programlisting" data-language="js" id="glvertexattrib">        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">vertexAttribPointer</code><code class="p">(</code><code class="nx">shaderTexCoordAttribute</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">texCoordSize</code><code class="p">,</code> <code class="nx">gl</code><code class="p">.</code><code class="nx">FLOAT</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindBuffer</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">ELEMENT_ARRAY_BUFFER</code><code class="p">,</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">indices</code><code class="p">);</code></strong></span>

        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderProjectionMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">projectionMatrix</code><code class="p">);</code>
        <code class="nx">gl</code><code class="p">.</code><code class="nx">uniformMatrix4fv</code><code class="p">(</code><code class="nx">shaderModelViewMatrixUniform</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">modelViewMatrix</code><code class="p">);</code>

        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">activeTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE0</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">bindTexture</code><code class="p">(</code><code class="nx">gl</code><code class="p">.</code><code class="nx">TEXTURE_2D</code><code class="p">,</code> <code class="nx">webGLTexture</code><code class="p">);</code></strong></span>
        <span class="strong"><strong><code class="nx">gl</code><code class="p">.</code><code class="nx">uniform1i</code><code class="p">(</code><code class="nx">shaderSamplerUniform</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></strong></span></pre></div>
</div>
</div>
<div class="sect1" data-original-filename="ch02.xml" id="chapter_summary">
<div class="titlepage"><div><div><h2 class="title">Chapter Summary</h2></div></div></div>
<p id="this_chapter_sh">This chapter showed us how to use the WebGL API to render graphics. We went through the basics of setting up a WebGL application, including creating a context, viewports, buffers, matrices, shaders and drawing primitives. We explored how to create 2D and 3D geometry and paint it with colors and bitmap textures. We even got a little help from open source libraries <code class="literal">glMatrix</code> and <code class="literal">RequestAnimationFrame</code>, two staples of WebGL development.</p>
<p id="it_should_be_ap">It should be apparent by now that WebGL programming, at its lowest level, is a lot of work. We were able to get somewhat complex geometry with colors and textures moving around on the page; however it took hundreds of lines of code. There is huge power in there—you can do practically anything you can imagine to every vertex and pixel on the screen, at blinding, hardware-accelerated speeds. But it requires heavy lifting. The designers of the standard made a conscious decision to trade size for power. The API is small and simple, at the cost of having to do a lot of coding on the application side.</p>
<p id="if_youre_an_ex">If you’re an experienced game or graphics programmer and you want to have fine control over the performance and feature set of your application, working directly with the WebGL API might be right for you. If you are building an application with very specific rendering requirements, say an image-processing application or 3D modeling tool, staying close to the WebGL metal is probably your best option. You will still probably want to build some abstractions on top—nobody wants to write the same 40 lines of code over and over again to create a cube, for example—but that layer will be all your own and you will know and control every line of code.</p>
<p id="however_if_you">However, if you are a mere mortal like most of us, you will want to work at a higher level than WebGL, hopefully by using tools that have already been developed. The good news is that several already exist: there are some great open source libraries built on top of WebGL. We will be exploring them in the next several chapters. Let’s get to it.</p>
</div></section>